<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 迭代总结(更新)]]></title>
    <url>%2F2019%2F04%2F04%2F2019-04-04-Python%E8%BF%AD%E4%BB%A3%E6%80%BB%E7%BB%93%EF%BC%88%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[迭代 IterableIterable Definition:Any object from which the iter built-in function can obtain an iterator. Objects implementing an __iter__ method returning an iterator are iterable. Sequence are always iterable; as are objects implementing a __getitem__ method that takes 0-based indexes. 什么是可迭代的(Iterable)？就是内置iter函数可以从中(Iterable)获取到iterator。实现了__iter__的对象是可迭代的(Iterable)。所有序列都是可迭代的，特指实现了__getitem__的object，并且要求__getitem__是以整数为下标的。 An object is considered iterable not only when it implements the special method __iter__, but also when it implements __getitem__, as long as __getitem__ accepts int keys starting from 0. 我们再来看一下Python官网对于iter()函数的定义： iter(object[, sentinel])¶ Return an iterator object. The first argument is interpreted very differently depending on the presence of the second argument. Without a second argument, object must be a collection object which supports the iteration protocol (the __iter__() method), or it must support the sequence protocol (the __getitem__() method with integer arguments starting at 0). If it does not support either of those protocols, TypeError is raised. If the second argument, sentinel, is given, then object must be a callable object. The iterator created in this case will call object with no arguments for each call to its __next__() method; if the value returned is equal to sentinel, StopIteration will be raised, otherwise the value will be returned. iter接受一个object作为参数，返回一个iterator对象。如果第二个参数没有给定，那么接收的object参数必须是实现了迭代协议（也就是实现了__iter__()函数）的对象、或者是实现了getitem，接收参数从0开始的对象。如果不是，则会产生TypeError。 Iterator123456789101112&gt;&gt;&gt; s = 'ABC'&gt;&gt;&gt; it = iter(s)&gt;&gt;&gt; while True:... try:... print(next(it))... except StopIteration:... del it... break... ABC StopIteration代表iterator已经走到了尽头。 标准的iterator接口有两个：①__next__:返回下一个可用的元素，若没有更多的元素，则返回StopIteration。②__iter__:返回iterator self。它允许iterator被当成iterable来访问，特别是在循环中使用。 因为只有这两个接口，所以不能检查一个iterator是否还有剩余元素。并且不能重置一个iterator。如果需要从头开始，必须要使用iter(iterable)，使用iter(iterator)本身是没用的，因为__iter__返回的是它自己。 Iterator DefinenationAny object that implements the next no-argument method that returns the next item in a series or raises StopIteration when there are no more items. Python iterators also implement the iter method so they are iterable as well. Generator函数体内包含yield关键字的函数都是一个生成器函数(generator function)。这个函数返回一个生成器对象(generator object)。换句话说，一个生成器函数就是一个生成器工厂。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; def gen_123():... yield 1... yield 2... yield 3... &gt;&gt;&gt; def gen_123():... for i in range(1, 4):... yield i...&gt;&gt;&gt; gen_123&lt;function gen_123 at 0x10475af28&gt;&gt;&gt;&gt; gen_123()&lt;generator object gen_123 at 0x1049bb990&gt;&gt;&gt;&gt; for i in gen_123():... print(i)... 123&gt;&gt;&gt; g = gen_123()&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)2&gt;&gt;&gt; next(g)3&gt;&gt;&gt; next(g)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;StopIteration 小窍门：如何看带有yield的函数：统一把yield看为return。从函数执行开始一直到yield，返回yield后面的变量。如果对该生成器使用next，则会从返回的yield开始执行，一直碰到下一个yield，或是遇到StopIteration。 Lazy Implementation使用yield，也就是生成器的作用就是实现懒加载，通常我们实现一个迭代器都是将元素一起塞到一个列表中，如果用户只需要前面几个元素，就会造成内存的浪费。所以使用yield来实现懒加载，可以更加节省内存。 Generator ExpressionA generator expression can be understood as a lazy version of a list comprehension: it does not eagerly build a list, but returns a generator that will lazily produce the items on demand. In other words, if a list comprehension is a factory of lists, a generator expression is a factory of generators. 生成器表达式是列表生成式的懒加载版本。它不像列表生成式一样一次性生成所有的元素全部加载到内存中。而是调用一次next，取出下一个元素。只需要把列表生成式的[]变为() 12list_comprehension = [x for x in range(10)]generator_expression = (x for x in range(10)) Example① 在以下代码中，A可以看做是Iterable，B可以看做是Iterator，C可以看做是Generator。 12345678910111213141516171819202122232425262728293031class A: # as Iterable def __init__(self): self.l = [1, 2, 3, 4] def __getitem__(self, item): return self.l[item]class B: # as Iterator def __init__(self): self.l = [1, 2, 3, 4] self.c = -1 def __iter__(self): return self def __next__(self): if self.c &lt; len(self.l) - 1: self.c += 1 return self.l[self.c] else: raise StopIteration class C: # as generator def __init__(self): self.l = [1, 2, 3, 4] def __iter__(self): for i in self.l: yield i ② Iterable和Iterator的设计不能混为一谈，必须分开设计 A common cause of errors in building iterables and iterators is to confuse the two. To be clear: iterables have an iter method that instantiates a new iterator every time. Iterators implement a next method that returns individual items, and an iter method that returns self. Therefore, iterators are also iterable, but iterables are not iterators. 12345678910111213141516171819202122232425262728293031323334import reimport reprlibRE_WORD = re.compile('\w+')class Sentence: # as Iterable def __init__(self, text): self.text = text self.words = RE_WORD.findall(text) def __repr__(self): return 'Sentence(%s)' % reprlib.repr(self.text) def __iter__(self): # return a iterator return SentenceIterator(self.words) class SentenceIterator: # as Iterator def __init__(self, words): self.words = words self.index = 0 def __next__(self): try: word = self.words[self.index] except IndexError: raise StopIteration() self.index += 1 return word def __iter__(self): return self]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>迭代器</tag>
        <tag>可迭代对象</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django+ECharts展示图表]]></title>
    <url>%2F2018%2F07%2F21%2F2018-07-21-Django%2BECharts%E5%B1%95%E7%A4%BA%E5%9B%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Django + ECharts展示图表开发环境： MacOS + Pycharm + Chrome Django + Python3.6 + ECharts 1、安装Django（安装完成可跳过此步）打开终端，输入 1sudo pip3 install django 等待安装完成 2、新建Django项目在Pycharm的启动界面创建新项目，并命名为DataVisualization。创建成功后新建DjangoAPP 然后输入 1startapp ECharts 创建成功后将ECharts加入settings.py的INSTALLED_APPS中 12345678910INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'ECharts',] 接着在ECharts文件夹中新建两个文件夹，分别为templates和static。 在templates文件夹中新建home.html文件： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Echarts&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello, world&lt;/body&gt;&lt;/html&gt; 创建完成后，修改ECharts中的views.py： 12345678from django.shortcuts import render# Create your views here.from django.http import HttpResponsedef index(request): return render(request, 'home.html') 然后打开urls.py，修改为以下内容： 12345678910from django.contrib import adminfrom django.urls import pathfrom ECharts import views as chartsViewsurlpatterns = [ path('admin/', admin.site.urls), path('', chartsViews.index, name='home'), # 添加的内容] 运行项目，发现界面上显示为Hello，world 3、下载ECharts文件，放入项目中下载地址 在这里我选择了完整版，下载后得到文件echarts.min.js，并将该文件拷贝至项目中。放入刚刚创建的static文件夹中。 检查settings.py文件最后是否包含有字段 1STATIC_URL = '/static/' 如果有则进行下一步，打开home.html，在head中加入内容： 1234567&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Echarts&lt;/title&gt; &#123;# 引入Echarts文件 #&#125; &#123;% load static %&#125; &lt;script src="&#123;% static 'echarts.min.js' %&#125;"&gt;&lt;/script&gt;&lt;/head&gt; 这样就把ECharts引入了进来 按照ECharts官网的介绍，修改body内容： 1234567891011121314151617181920212223242526272829&lt;body&gt;&#123;&#123; string &#125;&#125;&lt;div id="main" style="width: 600px;height: 400px;"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var myChart = echarts.init(document.getElementById('main'), 'dark'); var x_data_name = &#123;&#123; x_data|safe &#125;&#125;; var option = &#123; title:&#123; text: 'ECharts入门演示' &#125;, tooltip:&#123;&#125;, legend:&#123; data: "销量" &#125;, xAxis:&#123; data: x_data_name &#125;, yAxis:&#123;&#125;, series:[&#123; name:'销量', type:'bar', data:[5, 20, 36, 10, 10, 20] &#125;] &#125;; myChart.setOption(option);&lt;/script&gt;&lt;/body&gt; 其中第二行和第六行 为Django传进来的数据，分别用在html中和js中： 修改views.py： 123456789import jsondef index(request): string = 'ECharts第一张表格' x_data = ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"] return render(request, 'home.html', &#123; 'string': string, 'x_data': json.dumps(x_data), &#125;) 再次运行，可得最终界面：]]></content>
      <tags>
        <tag>Python Django ECharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac + Github Pages + Hexo + Next搭建个人博客]]></title>
    <url>%2F2018%2F04%2F13%2F2018-04-13-Mac%20%2B%20Github%20Pages%20%2B%20Hexo%20%2B%20Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Mac + Github Pages + Hexo + Next搭建个人博客一、准备：Mac 拥有Github账号，但是SSH未配置 homebrew已安装 二、建立Github Pages仓库1、登录Github，创建仓库，名字为：[个人github名字] + github.io，比如我自己的：wang-chenyi.github.io。README勾选，里面填写Blog（随意填写，介绍即可）。 2、然后会进入到此仓库界面 三、配置SSH官方教程 输入下面这行命令，email为注册github的email 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; This creates a new ssh key, using the provided email as a label. 1Generating public/private rsa key pair. 点击回车进入将ssh文件存到默认位置：（/Users/you/.ssh/id_rsa） 1Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] 输入加密串，点击回车不设置加密串。 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 然后出现一副奇奇怪怪的画就表示成功了。 将刚刚生成的SSH添加到Github中在终端中输入： 1vi /Users/your_name/.ssh/id_rsa.pub 复制里面的所有内容，然后进入Github，点击头像，选择Settings，然后再选择SSH and GPG keys，点击New SSH key。将刚刚复制的内容拷贝进去就可以了。 检查是否成功： 1$ ssh -T git@GitHub.com 然后提示是否连接，输入Yes即可 12345The authenticity of host 'github.com (13.250.177.223)' can't be established.RSA key fingerprint is ******.Are you sure you want to continue connecting (yes/no)? yes # 在这里Warning: Permanently added 'github.com,13.250.177.223' (RSA) to the list of known hosts.Hi wang-chenyi! You've successfully authenticated, but GitHub does not provide shell access. 到此SSH配置成功。 然后在浏览器中输入[your_github_id].github.io，其中显示了readme里面的内容，即表示成功。 四、安装Hexo0、检查brew是否安装：1brew -v 若出现版本号则表明已安装 1、通过brew安装Node.js1brew install node 2、通过npm安装hexo1npm install -g hexo-cli 3、Hexo建站123$ hexo init blog # blog是自己起的名字，在当前文件夹下建立，建议选择自己熟悉的文件夹$ cd blog # 进入文件夹$ npm install 安装在 .ssh文件夹中，blog目录里的内容如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 简单介绍一下比较重要的文件 _config.yml网站的配置文件，可以在此配置大部分参数 source资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题文件夹，后面我们使用的next主题即会存放在此。 _posts存储你发表在博客上的文章，当Hexo 初始化一个站点时，里面会有一篇默认的博文。 4、Hexo测试1234$ cd blog$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 进入会看到初始界面 五、Hexo部署到Git1、安装hexo-deployer-git1npm install hexo-deployer-git --save 2、配置_config.yml修改内容： 1234deploy: type: git repo: &lt;repository url&gt; # your_id.github.io 这一项目的git地址 # branch: master 按要求输入Github的账号和密码 注意：所有冒号后面必须是空格，否则会报错 \为url地址，可通过如下找到 接着执行 123$ hexo clean$ hexo g$ hexo d 访问 your_id.github.io并刷新发现显示为hexo的初始化界面 六、安装Next主题官方指南中文版，详细介绍了如何安装next主题 1、使用git下载next主题12$ cd your-hexo-site # 刚刚的hexo的路径，我的是blog，如果终端没有关闭应该还在这个地址$ git clone https://github.com/iissnan/hexo-theme-next themes/next 2、启用next主题在站点根目录下的配置文件 _config.yml 中，找到 theme字段，并将其值更改为 next。 1theme: next #冒号后有空格# 3、验证控制台进入站点目录下输入命令： 1hexo s --debug 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse： 七、Next主题定制：官方配置指南 具体配置情况 - 作者：shenzekun 九、参考：https://blog.csdn.net/qq_34290780/article/details/78230706 http://theme-next.iissnan.com/theme-settings.html https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空间滤波与频率域滤波（二）：频率域滤波]]></title>
    <url>%2F2018%2F04%2F10%2F2018-04-10-%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2%E4%B8%8E%E9%A2%91%E7%8E%87%E5%9F%9F%E6%BB%A4%E6%B3%A2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E9%A2%91%E7%8E%87%E5%9F%9F%E6%BB%A4%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[频率域滤波一、频率域滤波基础1、频率域滤波基础频率域滤波由 修改一副图像的傅里叶变换 然后计算其反变换得到处理后的结果组成。滤波公式： 低频分量 对应图像中缓慢变换的灰度分量。如室内的墙壁和少云的天空。 直流分量 等于图像的平均灰度级。同时也是未移位之前的傅里叶图像最左上角的值，移位之后的中点值。 高频分量 对应图像中变化剧烈的图像分量。如边缘和噪声。 低通滤波器 衰减高频而通过低频的滤波器 近似称为，将模糊一副图像。 高通滤波器 与之相反的称为，将增强尖锐的细节，但是将导致图像的对比度降低。原因是高通滤波器消去了直流项。对滤波器加上一个小常数不会印象尖锐性，但是它的确能放置直流项的消除，并且保留色调。 2、频率域滤波步骤小结1）给定一副大小为 M×N 的输入图像 f(x, y)，使用参数P、Q填充图像，使 P = 2M，Q = 2N 2）对 f(x, y) 添加必要数量的 0，形成大小为 P×Q 的填充后图像 fp(x, y) 3）使用(-1)^(x + y) 乘以 fp(x, y)，将其移到变换的中心。 4）计算步骤3的DFT，得到 F(u, v) 5）生成一个实对称滤波函数 H(u, v)，大小为 P×Q，中心为 (P/2, Q/2) 。然后计算 G(u, v) = H(u, v)F(u, v)；即G(i, k) = H(i, k) * F(i, k)。 6）得到处理后的图像： 7）通过从gp(x, y) 的左上象限提取 M×N，得到最终处理结果 g(x, y)。 用图像显示： 3、空间和频率域滤波之间的对应空间域和频率域滤波之前的纽带是 卷积定理。可得 h(x, y)为空间滤波器，H(u, v)为频率域滤波器。h(x, y)可以由频率域滤波器对一个冲激的响应得到。并且因为 h(x, y) ↔ H(u, v)，这样的离散实现中所有数值都是有限的，这样的滤波器称为 有限冲激响应(FIR)滤波器。 二、使用频率域滤波平滑图像布特沃斯滤波器有一个参数，称为滤波器的“阶数”，当阶数值较高时，布特沃斯滤波器接近于理想滤波器，对于较低的阶数值，布特沃斯滤波器更像高斯滤波器。 1、理想低通滤波器在以原点为中心，以D0位半径的圆内，无衰减的通过所有频率，而在圆外‘切断’所有频率的二维低通滤波器，称为理想低通滤波器 (ILPF) 。由下面的函数确定 其中PQ为填充后的尺寸。理想这一名称表明在半斤为D0的圆内，所有频率无衰减的通过，而在圆外的所有频率则完全被滤除。 理想低通滤波器存在“振铃”情况，ILPF的模糊和振铃特性可以使用卷积定理来解释。因为ILPF在频率域的剖面图类似于盒装滤波器，所以相应的空间滤波器具有 sinc 函数的形状。空间域滤波可以通过h(x, y)和图像卷积来实现。sinc函数的中心波瓣是引起模糊的主因，而外侧较小的波瓣是造成振铃的主要原因。所以理想低通滤波器并不是十分实用。 2、布特沃斯低通滤波器截止频率位于距原点D0处的n阶布特沃斯低通滤波器（BLPF）的传递函数定义为： 其中BLPF函数的透视图、图像显示和径向剖面图： 在空间域的一阶波特沃斯滤波器没有振铃现象。在二阶滤波器中，振铃现象通常很难察觉。然而阶数越大，振铃现象越明显。 3、高斯低通滤波器一维低通滤波器（GLPF）在上一节有介绍，目的是寻找空间域和频率域之间的重要联系。这些滤波器的二维形式： 因为GLPF的傅里叶反变换也是高斯的，所以通过IDFT得到的空间高斯滤波器将没有振铃。 4、Matlab实验-低通滤波此实验按照频率域滤波步骤进行滤波处理 123456789101112131415161718192021222324252627282930313233343536&gt;&gt; clear all;&gt;&gt; i = imread('liftingbody.png');&gt;&gt; i = im2double(i);&gt;&gt; M = 2 * size(i, 1); % 将图像拓展至两倍&gt;&gt; N = 2 * size(i, 2);&gt;&gt; u = -M/2:(M/2 - 1); % 因为D(u, v)是频率域(u,v)到中心的距离。所以根据公式先计算平方里面的数值。&gt;&gt; v = -N/2:(N/2 - 1);&gt;&gt; [U, V] = meshgrid(u, v); % 然后将数值转化为一个个坐标&gt;&gt; D = sqrt(U.^2 + V.^2); % 再计算D即可&gt;&gt; D0 = 80; % 半径&gt;&gt; H1 = double(D &lt;= D0); % 理想低通滤波器的公式&gt;&gt; J1 = fftshift(fft2(i, size(H1, 1), size(H1, 2))); % 对图像进行傅里叶变换到 频率域，并且进行移位&gt;&gt; K1 = J1 .* H1; % 然后再频率域进行点乘&gt;&gt; L1 = ifft2(ifftshift(K1)); % 计算完后计算反傅里叶变换&gt;&gt; L1 = L1(1:size(i, 1), 1:size(i, 2)); % 然后取左上方的值&gt;&gt; subplot(221);imshow(i);&gt;&gt; title('原始图像');&gt;&gt; subplot(222);imshow(L1);&gt;&gt; title('理想低通滤波器');&gt;&gt; &gt;&gt; n = 6; % 会存在振铃现象&gt;&gt; H2 = 1./(1+(D./D0).^(2*n)); % 布斯特沃低通滤波器公式&gt;&gt; J2 = fftshift(fft2(i, size(H2, 1), size(H2, 2)));&gt;&gt; K2 = J2 .* H2;&gt;&gt; L2 = ifft2(ifftshift(K2));&gt;&gt; L2 = L2(1:size(i, 1), 1:size(i, 2));&gt;&gt; subplot(223);imshow(L2);&gt;&gt; title('布斯特沃低通滤波器');&gt;&gt; &gt;&gt; H3 = exp(-(D.^2)./(2*(D0.^2))); % 高斯低通滤波器公式&gt;&gt; J3 = fftshift(fft2(i, size(H3, 1), size(H3, 2)));&gt;&gt; K3 = J3.*H3;&gt;&gt; L3 = ifft2(ifftshift(K3));&gt;&gt; L3 = L3(1:size(i, 1), 1:size(i, 2));&gt;&gt; subplot(224);imshow(L3);&gt;&gt; title('高斯低通滤波器'); 三种滤波器公式总结： 三、使用频率域滤波锐化图像一个高通滤波器是从给定的低通滤波器用下式得到的： 1、理想高通滤波器二维理想高通滤波器（IHPF）定义为： 2、布特沃斯高通滤波器截止频率为D0的n阶布特沃斯高通滤波器（BHPF）定义为： 与低通滤波器一样，布特沃斯高通滤波器比IHPF更平滑，截止频率越大，使用BHPF得到的图像就越平滑 3、高斯高通滤波器截止频率出在距频率矩形中心为D0的高斯高通滤波器（GHPF）的传递函数由下式给出： 三种高通滤波器总结： 4、频率域的拉普拉斯算子拉普拉斯算子可由如下滤波器在频率域实现： 在频率域，4.9-8可写为： 5、钝化模板、高提升滤波和高频强调滤波在空间滤波中提到过的钝化模板，在频率域方法中由下式给出： 6、同态滤波图像的照射分量通常由慢的空间变化来表征，而反射分量往往引起突变，特别是在不同物体的连接部分，这些特性导致图像取对数后的傅里叶变换的低频成分和照射相联系，高频成分与反射相联系。虽然这些联系只是初略的近似，但是在图像滤波中是有效的。 使用同态滤波器可以更好的控制照射分量和反射分量。这种控制需要指定一个滤波器函数H(u, v)，它可用不同的可控方法影响傅里叶变换的低频和高频成分。 如果 yL和yH选定，而 yL\&lt;1，yH>1，那么上图的滤波器函数趋向于衰减低频（照射）的贡献，而增强高频（反射）的贡献，最终结果是同时进行动态范围的压缩和对比度的增强。常数c控制函数坡度的锐利度，在yL和yH之间过渡。 7、Matlab实验–高通滤波器1234567891011121314151617181920212223242526272829&gt;&gt; clear all;&gt;&gt; i = imread('coins.png');&gt;&gt; i = im2double(i);&gt;&gt; subplot(221);imshow(i);&gt;&gt; title('原始图像');&gt;&gt; &gt;&gt; M = 2 * size(i, 1);&gt;&gt; N = 2 * size(i, 2);&gt;&gt; u = -M/2:(M/2 - 1);&gt;&gt; v = -N/2:(N/2 - 1);&gt;&gt; [U, V] = meshgrid(u, v);&gt;&gt; D = sqrt(U.^2+V.^2);&gt;&gt; D0 = 30;&gt;&gt; n = 6;&gt;&gt; H2 = 1./(1 + (D0./D).^(2 * n));&gt;&gt; J2 = fftshift(fft2(i, size(H2, 1), size(H2, 2)));&gt;&gt; K2 = J2 .* H2;&gt;&gt; L2 = ifft2(ifftshift(K2));&gt;&gt; L2 = L2(1:size(i,1), 1:size(i, 2));&gt;&gt; subplot(222);imshow(L2);&gt;&gt; title('布特沃斯高通滤波器');&gt;&gt; &gt;&gt; H3 = 1 - exp(-(D.^2)./(2 * (D0.^2)));&gt;&gt; J3 = fftshift(fft2(i, size(H3, 1), size(H3, 2)));&gt;&gt; K3 = J3.*H3;&gt;&gt; L3 = ifft2(ifftshift(K3));&gt;&gt; L3 = L3(1:size(i,1), 1:size(i, 2));&gt;&gt; subplot(223);imshow(L3);&gt;&gt; title('高斯高通滤波器'); 四、选择性滤波1、带阻滤波器和带通滤波器 2、Matlab实验 — 带阻滤波器1234567891011121314151617181920212223242526272829303132333435&gt;&gt; clear all;&gt;&gt; i = imread('coins.png');&gt;&gt; subplot(221);imshow(i);&gt;&gt; title('原始图像');&gt;&gt; &gt;&gt; i = imnoise(i, 'gaussian', 0, 0.015); % 添加噪声&gt;&gt; subplot(222);imshow(i);&gt;&gt; title('带噪声图像');&gt;&gt; &gt;&gt; i = im2double(i);&gt;&gt; M = 2 * size(i, 1);&gt;&gt; N = 2 * size(i, 2);&gt;&gt; u = -M/2:(M/2 - 1);&gt;&gt; v = -N/2:(N/2 - 1);&gt;&gt; [U, V] = meshgrid(u, v);&gt;&gt; d = sqrt(U.^2 + V.^2);&gt;&gt; d0 = 50;&gt;&gt; w = 30;&gt;&gt; h1 = double(or(d &lt;(d0 - w / 2), d&gt; d0 + w/2));&gt;&gt; j1 = fftshift(fft2(i, size(h1, 1), size(h1, 2)));&gt;&gt; k1 = j1 .* h1;&gt;&gt; l1 = ifft2(ifftshift(k1));&gt;&gt; l1 = l1(1:size(i, 1), 1:size(i, 2));&gt;&gt; subplot(223);imshow(l1);&gt;&gt; title('理想带阻滤波器');&gt;&gt; &gt;&gt; n = 6;&gt;&gt; h1 = 1./((1 + ((d.*w)./(d.^2 - d0.^2)).^(2 * n)));&gt;&gt; h2 = h1;&gt;&gt; j2 =fftshift(fft2(i, size(h2, 1), size(h2, 2)));&gt;&gt; k2 = j2 .* h2;&gt;&gt; l2 = ifft2(ifftshift(k2));&gt;&gt; l2 = l2(1:size(i, 1), 1:size(i, 2));&gt;&gt; subplot(224);imshow(l2);&gt;&gt; title('布特沃斯带阻滤波器'); 3、Matlab实验 — 同态滤波器12345678910111213141516171819202122232425 &gt;&gt; i = imread('lean.jpg');&gt;&gt; subplot(121);imshow(i);&gt;&gt; title('原始图像');&gt;&gt; j = double(i);&gt;&gt; f= fft2(j);&gt;&gt; g = fftshift(f);&gt;&gt; [M, N] = size(f);&gt;&gt; d0 = 10;&gt;&gt; r1 = 0.5;&gt;&gt; rh = 2;&gt;&gt; c = 4;&gt;&gt; n1 = floor(M/2);&gt;&gt; n2 = floor(N/2);&gt;&gt; for i = 1:M for j = 1:N d = sqrt((i - n1)^2 + (j - n2)^2); h = (rh - r1) * (1 - exp( -c * (d .^2 /d0.^2))) + r1; g(i, j) = h * g(i, j); endend&gt;&gt; g = ifftshift(g);&gt;&gt; g = uint8(real(ifft2(g)));&gt;&gt; subplot(122);imshow(g);&gt;&gt; title('同态滤波器');]]></content>
      <categories>
        <category>数字图像处理</category>
        <category>matlab</category>
        <category>滤波</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>matlab</tag>
        <tag>滤波</tag>
        <tag>频率</tag>
        <tag>傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空间滤波与频率域滤波（一）：空间滤波]]></title>
    <url>%2F2018%2F04%2F04%2F2018-04-04-%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2%E4%B8%8E%E9%A2%91%E7%8E%87%E5%9F%9F%E6%BB%A4%E6%B3%A2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[空间滤波滤波指接受（通过）或拒绝一定的频率分量。通过低频的滤波器称为 低通滤波器，因为低频表示一副图像中变化缓慢的区域，所以低通滤波器的效果是模糊（平滑）一副图像。同理存在 高通滤波器 一、空间滤波基础1、空间滤波机理：1）新像素点 g(x, y)： 空间滤波机理： ​ 2、空间相关与卷积相关是滤波器模板移过图像并计算每个位置乘积之和的处理，卷积的机理相似，但是滤波器要旋转180°。下图为一维操作的相关和卷积操作 二维与一维相似，下图为二维情况下的相关和卷积操作 使用符号记录相关和卷积： 相关： 卷积： 3、Matlab实验：滤波的实现1）基础用法：imfilter函数 – 5 * 5的均值滤波1234567&gt;&gt; i = imread('coins.png');&gt;&gt; subplot(121);imshow(i);&gt;&gt; title('原始图像');&gt;&gt; h = ones(5, 5) / 25;&gt;&gt; i2 = imfilter(i, h);&gt;&gt; subplot(122);imshow(i2);&gt;&gt; title('均值滤波'); 2）相关和卷积利用imfilter函数进行滤波时可以使用相关核或卷积核进行操作。默认为相关核，如要使用卷积核，则使用参数&#39;conv&#39;。 1234567891011121314151617181920212223242526272829303132&gt;&gt; clear all;&gt;&gt; a = magic(5);&gt;&gt; aa = 17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9&gt;&gt; h = [-1 0 1]; % 操作核&gt;&gt; imfilter(a, h)ans = 24 -16 -16 14 -8 5 -16 9 9 -14 6 9 14 9 -20 12 9 9 -16 -21 18 14 -16 -16 -2&gt;&gt; imfilter(a, h, 'conv') % 正负号改变ans = -24 16 16 -14 8 -5 16 -9 -9 14 -6 -9 -14 -9 20 -12 -9 -9 16 21 -18 -14 16 16 2 3）边界填充选项imfilter函数默认将边界的像素值补充为 0，称为 0填充。使用 0填充进行滤波时，图像周围可能产生黑色边界。为了去除黑色边界，imfilter使用另一种称为边界复制的边界填充方法，在这种方法中，图像边界外的像素值有距离边界最近的像素值决定。 Boundary Options X 输入图像的外部边界通过 X 来拓展，默认 X = 0 symmetric 输入图像的外部边界通过镜像反射器内部边界来拓展 replicate 输入图像的外部边界通过复制内部边界的值来拓展 circular 输入图像的边界通过假设输入图像是周期函数来拓展 12345678910111213&gt;&gt; clear all&gt;&gt; i = imread('peppers.png');&gt;&gt; subplot(131);imshow(i);&gt;&gt; title('原始图像');&gt;&gt; h = ones(5, 5)/25;&gt;&gt; i2 = imfilter(i, h);&gt;&gt; subplot(132);imshow(i2);&gt;&gt; title('0填充');&gt;&gt; i3 = imfilter(i, h, 'replicate');&gt;&gt; subplot(133);imshow(i3);&gt;&gt; title('边界复制填充'); 4）预定义滤波器(核) - fspecial函数具体语法详情可参照matlab的语法。定义语法： h = fspecial(&#39;average&#39;,hsize) 均值滤波器 h = fspecial(&#39;disk&#39;,radius) 有 (radiuns * 2 + 1)个边的圆形均值滤波器 h = fspecial(&#39;gaussian&#39;,hsize,sigma) 标准偏差为 sigma，大小为 hsize 的高斯低通滤波器 h = fspecial(&#39;laplacian&#39;,alpha) 系数由 alpha (0.0 ~ 1.0) 决定的二维拉普拉斯操作 h = fspecial(&#39;log&#39;,hsize,sigma)标准偏差为 sigma，大小为 hsize 的高斯滤波器旋转对称拉氏算子。。。 h = fspecial(&#39;motion&#39;,len,theta) 角度 theta 移动 len个像素的运动滤波器 h = fspecial(&#39;prewitt&#39;) 近似计算垂直梯度的水平边缘强调算子 h = fspecial(&#39;sobel&#39;) 近似计算垂直梯度光滑效应的水平边缘强调算子 h = fspecial(&#39;unsharp&#39;, alpha) 根据alpha决定的拉氏算子创建的掩模滤波器 1234567891011121314i = imread('cameraman.tif');&gt;&gt; subplot(221);imshow(i);&gt;&gt; title('原始图像')&gt;&gt; h = fspecial('motion', 20, 45);&gt;&gt; MotionBlur = imfilter(i, h, 'replicate');&gt;&gt; subplot(222);imshow(MotionBlur);&gt;&gt; title('运动滤波器');&gt;&gt; h = fspecial('disk', 10);&gt;&gt; blurred = imfilter(i, h, 'replicate');&gt;&gt; subplot(223);imshow(blurred);&gt;&gt; h = fspecial('unsharp');&gt;&gt; sharpened = imfilter(i, h, 'replicate');&gt;&gt; subplot(224);imshow(sharpened);&gt;&gt; title('掩模滤波器'); 二、平滑空间滤波器平滑滤波器用于模糊处理和降低噪声，模糊处理经常用于预处理任务中，例如在（大）目标中提取之前 去除图像中的一些琐碎细节等 1、平滑线性滤波器 2、统计排序（非线性）滤波器这种滤波器的响应以滤波器包围的图像区域中所包含的像素排序为基础，然后使用统计排序结果决定的值带图中心像素的值。这一类中最知名的为 中值滤波器 中值滤波器 将像素邻域内灰度的中值代替该像素的值。中值滤波器对处理脉冲噪声非常有效，该种噪声也称为 椒盐噪声。 3、Matlab实验：图像的统计特性1）图像均值使用mean2计算矩阵的均值。 1234567891011121314151617&gt;&gt; clear all&gt;&gt; i = imread('onion.png');&gt;&gt; j = rgb2gray(i);&gt;&gt; gray = mean2(j);&gt;&gt; rgb = mean2(i);&gt;&gt; r = mean2(i(:,:,1))r = 137.3282&gt;&gt; g = mean2(i(:,:,2))g = 92.7850&gt;&gt; b = mean2(i(:,:,3))b = 45.2651&gt;&gt; graygray = 100.6817 2）图像的标准差matlab使用std函数计算向量的标准差，用std2来计算矩阵的标准差。 1234567891011&gt;&gt; clear all;&gt;&gt; i = imread('liftingbody.png');&gt;&gt; s1 = std2(i);&gt;&gt; j = histeq(i);&gt;&gt; s2 = std2(j);&gt;&gt; s1s1 = 31.6897&gt;&gt; s2s2 = 74.8416 3）图像的相关系数matlab提供了corr2函数计算两个灰度图像的相关系数。 1234567&gt;&gt; clear all;&gt;&gt; i = imread('pout.tif');&gt;&gt; j = medfilt2(i); % 中值滤波器&gt;&gt; r = corr2(i, j);&gt;&gt; rr = 0.9959 得到两幅图像的相关系数为 0.9959，相似度非常高。 4）图像的等高线matlab使用 imcontour 来显示灰度图像中数据轮廓图，具体语法可查看matlab帮助 12345&gt;&gt; clear all;&gt;&gt; i = imread('onion.png');&gt;&gt; j = rgb2gray(i);&gt;&gt; subplot(121);imshow(j);&gt;&gt; subplot(122);imcontour(j); 三、锐化空间滤波器锐化处理的目的主要是突出灰度的过度部分 1、使用二阶微分进行图像锐化-拉普拉斯算子一个二维图像函数 f(x,y) 的拉普拉斯算子定义为: 将二阶微分定义为差分，在x方向： 在y方向 所以两个变量的拉普拉斯算子定义为： 因为拉普拉斯是一种微分算子，强调的是图像中灰度的突变。故拉普拉斯会产生把 浅灰色边线 和 突变点 叠加到暗色背景中的图像。将原图像和拉普拉斯图像叠加到一起，可以复原背景的特性，并且保持拉普拉斯锐化处理的效果。 ps：如果使用定义具有负的中心系数，那么必须将图像减去拉普拉斯变换后的图像，而不是加上它。 2、非锐化掩蔽和高提升滤波在印刷和出版界已用了多年的图像锐化处理过程是从原图像中减去一副非锐化（平滑过的）版本，称为 非锐化掩蔽。 步骤： ① 模糊原图像 ② 将原图像减去模糊图像（产生的差值称为模板） ③ 将模板加到原图像中 非锐化掩蔽公式描述如下： 3、使用一阶微分（非线性）进行图像锐化-梯度对于函数 f(x, y)，f 在坐标 (x, y) 处的梯度定义为： 该向量具有重要的几何特性，即它指出了在位置（x, y）处 f 的最大变化率方向 在图像中，记gx和gy为： 最终可得到： 4、Matlab实验：空间域滤波1）图像加入噪声matlab提供了 imnoise 函数对一副图像加入不同类型的噪声 1234567891011121314151617181920&gt;&gt; clear all;&gt;&gt; i = imread('eight.tif');&gt;&gt; subplot(231);imshow(i);&gt;&gt; title('原始图像');&gt;&gt; j1 = imnoise(i, 'gaussian', 0.15); % 高斯噪声&gt;&gt; subplot(232);imshow(j1);&gt;&gt; title('添加高斯噪声');&gt;&gt; j2 = imnoise(i, 'salt &amp; pepper', 0.15); % 椒盐噪声&gt;&gt; subplot(233);imshow(j2);&gt;&gt; title('椒盐噪声');&gt;&gt; j3 = imnoise(i, 'poisson'); % 泊松噪声 &gt;&gt; subplot(234);imshow(j3);&gt;&gt; title('poisson噪声');&gt;&gt; j4 = imnoise(i, 'speckle', 0.15);&gt;&gt; subplot(235);imshow(j4);&gt;&gt; title('乘法噪声'); 2）中值滤波器matlab使用 medfilt2 函数来进行中值滤波 123456789&gt;&gt; clear all;&gt;&gt; i = imread('eight.tif');&gt;&gt; figure;&gt;&gt; subplot(211);imshow(i);&gt;&gt; title('原始图像');&gt;&gt; j = imnoise(i, 'salt &amp; pepper', 0.02);&gt;&gt; k = medfilt2(j);&gt;&gt; subplot(212);imshowpair(j, k, 'montage');&gt;&gt; title('中值滤波器效果') 3）自适应滤波器metlab使用 winener2 函数来进行图像自适应滤波处理 12345678910111213&gt;&gt; clear all;&gt;&gt; rgb = imread('saturn.png');&gt;&gt; subplot(131);imshow(rgb);&gt;&gt; title('原始图像');&gt;&gt; i = rgb2gray(rgb);&gt;&gt; j = imnoise(i, 'gaussian', 0, 0.025);&gt;&gt; subplot(132);imshow(j)&gt;&gt; title('带有高斯噪声的图像');&gt;&gt; k = wiener2(j, [5,5]);&gt;&gt; subplot(133);imshow(k);&gt;&gt; title('自适应中值滤波') 4）排序滤波用法例： y = ordfilt2(X, 5, ones(3, 3)) 相当于 3×3的中值滤波 y = ordfilt2(X, 1, ones(3, 3)) 相当于 3×3的最小值滤波 y = ordfilt2(X, 9, ones(3, 3)) 相当于 3×3的最大值滤波 y = ordfilt2(X, 1, [0 1 0; 1 0 1; 0 1 0]) 输出的是每个像素的东、西、南、北4个方向的相邻像素灰度的最小值 1234567891011121314151617&gt;&gt; clear all;&gt;&gt; i = imread('circuit.tif');&gt;&gt; subplot(223);imshow(i);&gt;&gt; subplot(221);imshow(i);&gt;&gt; title('原始图像')&gt;&gt; b = ordfilt2(i, 25, true(5));&gt;&gt; subplot(222);imshow(b);&gt;&gt; title('排序滤波')&gt;&gt; j = imnoise(i, 'gaussian', 0, 0.025);&gt;&gt; subplot(223);imshow(j);&gt;&gt; title('高斯噪声');&gt;&gt; c = ordfilt2(j, 25, true(5));&gt;&gt; subplot(224);imshow(c);&gt;&gt; title('含噪排序滤波') 5）线性锐化滤波① 线性锐化滤波-拉普拉斯滤波器（会有一张专题介绍） 123456789101112131415161718&gt;&gt; clear all;&gt;&gt; i = imread('onion.png');&gt;&gt; h1 = [0 -1 0; -1 5 -1; 0 -1 0];&gt;&gt; h2 = [-1 -1 -1; -1 9 -1; -1 -1 -1];&gt;&gt; h1 0 -1 0 -1 5 -1 0 -1 0&gt;&gt; h2 -1 -1 -1 -1 9 -1 -1 -1 -1&gt;&gt; bw1 = imfilter(i, h1);&gt;&gt; bw2 = imfilter(i, h2);&gt;&gt; subplot(131);imshow(i);&gt;&gt; subplot(132);imshow(uint8(bw1));&gt;&gt; subplot(133);imshow(uint8(bw2)); ② Wallis算子（暂定） 6）非线性锐化1234567891011121314151617181920&gt;&gt; [i, map] = imread('lean.jpg');&gt;&gt; subplot(221);imshow(i);&gt;&gt; i = double(i);&gt;&gt; [ix, iy] = gradient(i); % 梯度&gt;&gt; gm = sqrt(ix .* ix + iy .* iy); % 梯度的幅度&gt;&gt; out1 = gm;&gt;&gt; subplot(222);imshow(uint8(out1), map); % 打印梯度图&gt;&gt; out2 = i;&gt;&gt; j = find(gm&gt;=15); % 梯度值大于15的，为边缘&gt;&gt; out2(j) = gm(j); % 将图中的寻找到的 j 替换为梯度图&gt;&gt; subplot(223);imshow(uint8(out2),map);&gt;&gt; &gt;&gt; out3 = i;&gt;&gt; j = find(gm&gt;=20); % 阈值黑白化&gt;&gt; out3(j) = 255;&gt;&gt; k = find(gm&lt;20);&gt;&gt; out3(k) = 0;&gt;&gt; subplot(224);imshow(uint8(out3),map);]]></content>
      <categories>
        <category>数字图像处理</category>
        <category>matlab</category>
        <category>滤波</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>matlab</tag>
        <tag>滤波</tag>
        <tag>拉普拉斯</tag>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode配置opencv3]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-xcode%E9%85%8D%E7%BD%AEopencv3%2F</url>
    <content type="text"><![CDATA[Xcode配置opencv3参考：http://charliegerard.github.io/blog/Installing-OpenCV/ 配置前提条件：opencv3在装opencv3+Python的时候已经安装好了，通过brew安装。现在直接进行配置 新建一个c++项目，起名为：OpenCV Tutorial，创建好之后，单击左边的选项卡中的项目文件 At the top, select Build Settings and search for Search Paths Change the Always Search User Paths to true. Change the Header Search Paths to /usr/local/include. Change Library Search Paths to /usr/local/lib. In the search field, remove your previous search and scroll down until you find the Linking section. Double click on Other Linker Flags, click on the + button and add: -lopencv_calib3d -lopencv_core -lopencv_features2d -lopencv_flann -lopencv_highgui -lopencv_imgcodecs -lopencv_imgproc -lopencv_ml -lopencv_objdetect -lopencv_photo -lopencv_shape -lopencv_stitching -lopencv_superres -lopencv_ts -lopencv_video -lopencv_videoio -lopencv_videostab 接着选择 preferences =&gt; Locations =&gt; Advanced，将 Unique 改为 Legacy。 然后在项目中创建一个文件夹。选择反键点击选择 Add Files to，使用 command + shift + g。进入/usr/local/Cellar/opencv/3.3.1_1/lib，将 libopencv_***添加进来，就完成了配置。 最后进行代码测试就可以了： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;int main(int argc, char *argv[])&#123; // Open the file. IplImage *img = cvCreateImage( cvSize(100,200), IPL_DEPTH_8U, 3); //if (!img) &#123; // printf("Error: Couldn't open the image file.\n"); // return 1; //&#125; // Display the image. cvNamedWindow("Image:", CV_WINDOW_AUTOSIZE); cvShowImage("Image:", img); // Wait for the user to press a key in the GUI window. cvWaitKey(0); // Free the resources. cvDestroyWindow("Image:"); cvReleaseImage(&amp;img); return 0;&#125; 运行成功会出现一个黑白各占一边的图像 问题在编译连接过程中会出现这个问题： 1ld: library not found for -lopencv_ts 解决方案：在刚刚配置的 Build Settings 中的 Other Linker Flags 中移除 -lopencv_ts]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Xcode</tag>
        <tag>c++</tag>
        <tag>opencv3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora Mac应用程序不响应解决方法]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-Typora%20Mac%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8D%E5%93%8D%E5%BA%94%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Typora Mac应用程序不响应解决方法打开新文稿后，Typora直接进入未响应状态，不管是重启还是重新下载应用程序都无法解决，网上也没有相关问题和解决方案。最后查明是因为有为保存的文稿未保存，导致Typora不能正常运行。只要找到文稿并且把未保存的文稿删掉就可以解决问题。 解决方案在Finder中进入Application中，选择Typora，反键选择“显示包内容”，然后进入Contents =&gt; MacOS =&gt; 双击Typora。然后再进程中会显示如下内容： 12345678Last login: Sat Mar 31 14:03:53 on console***deMacBook-Pro:~ ***$ /Applications/Typora.app/Contents/MacOS/Typora ; exit;2018-03-31 14:31:36.517 Typora[777:220236] Started app2018-03-31 14:31:36.517 Typora[777:220236] current version: 0.9.9.13.62018-03-31 14:31:36.517 Typora[777:220236] forceUpdateTheme: 02018-03-31 14:31:36.517 Typora[777:220236] init theme folder : 12018-03-31 14:31:36.533 Typora[777:220236] readFromPath: /Users/用户名/Library/Autosave Information/未存储的“Typora”文稿.md2018-03-31 14:31:36.598 Typora[777:220236] Could not find image named 'NSImageNameTouchBarTextListTemplate'. 然后发现未存储的文稿的位置：/Users/用户名/Library/AutosaveInformation/.... 使用Finder搜索此文稿，删掉，重启Typora就可以了。]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 通过SSH安装wordpress和nextcloud详细过程（CentOS+Nginx+MySQL+PHP7）]]></title>
    <url>%2F2018%2F03%2F30%2F2018-03-30-CentOS7-%E9%80%9A%E8%BF%87SSH%E5%AE%89%E8%A3%85wordpress%E5%92%8Cnextcloud%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B%EF%BC%88CentOS%2BNginx%2BMySQL%2BPHP7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CentOS7 安装Nginx、PHP、MySQLCentOS版本：https://segmentfault.com/a/1190000005348317 查看内核版本： 1cat /proc/version 查看系统版本： 12345678910111213# ls /etc|grep releasecentos-releasecentos-release-upstreamos-releaseredhat-releasesystem-releasesystem-release-cpe#cat /etc/centos-releaseCentOS Linux release 7.4.1708 (Core) 安装 nginx添加EPEL仓库：1yum install epel-release 使用yum安装nginx1yum install nginx 一路yes yes， 然后启动 nginx 1systemctl start nginx 也可以通过 nginx -s reload 来重启nginx 启动后通过IP来访问，在浏览器中输入：http://server_domain_name_or_ip/ 然后可以看到nginx服务已经启动 查询ip指令： 1ip addr show eth0 | grep inet | awk '&#123; print $2; &#125;' | sed 's/\/.*$//' 安装MySQL（MariaDB）1yum install mariadb-server mariadb 完成安装后，开启服务 1systemctl start mariadb 接着给MySQL添加密码： 1mysql_secure_installation 示例： 12345678910111213141516171819# mysql_secure_installationNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!In order to log into MariaDB to secure it, we'll need the currentpassword for the root user. If you've just installed MariaDB, andyou haven't set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MariaDBroot user without the proper authorisation.Set root password? [Y/n] yNew password: Re-enter new password: 然后完成最后的工作： 1systemctl enable mariadb 安装PHP添加PHP7-FPM webtatic仓库： 1rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 安装PHP和PHP-FPM： 1yum -y install php70w-fpm php70w-cli php70w-gd php70w-mcrypt php70w-mysql php70w-pear php70w-xml php70w-mbstring php70w-pdo php70w-json php70w-pecl-apcu php70w-pecl-apcu-devel` 安装完成后查看PHP的版本 1234# php -vPHP 7.0.27 (cli) (built: Jan 14 2018 09:00:22) ( NTS )Copyright (c) 1997-2017 The PHP GroupZend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies 然后修改/etc/php.ini 文件，在里面找到 cgi.fix_pathinfo=1，并设置为0 vi /etc/php.ini =&gt; cgi.fix_pathinfo=0 因为php默认为apach部署，故修改php-fpm的配置属性 1vi /etc/php-fpm.d/www.conf 将 user 和 group 从 apach 改为 nginx 12user = nginxgroup = nginx 接着启动服务： 12systemctl start php-fpmsystemctl enable php-fpm 测试展示PHP的信息页面，地址：/usr/share/nginx/html/wangchenyitest.local 在nginx中创建对应的conf： vi /etc/nginx/conf.d/virtual.conf 然后将下面的内容粘贴进去： 123456789101112131415server &#123; server_name 111.111.111.111; root /usr/share/nginx/html/wangchenyitest.local;location / &#123; index index.html index.htm index.php;&#125;location ~ \.php$ &#123; include /etc/nginx/fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/nginx/html/wangchenyitest.local$fastcgi_script_name;&#125;&#125; 然后创建 1mkdir /usr/share/nginx/html/wangchenyitest.local 这个仓库建好后，创建一个index.php 1vi /usr/share/nginx/html/wangchenyitest.local/index.php 在里面写这些内容： &lt;?php phpinfo(); ?&gt; 重启各种服务 123systemctl restart nginxsystemctl restart php-fpmsystemctl enable php-fpm 接着访问ip，会看到php的界面信息和数据库Mysql的信息。 安装firewalld服务 1yum install firewalld 安装完成后开启防火墙 12systemctl enable firewalldsystemctl start firewalld 添加http服务 12firewall-cmd --permanent --add-service=httpfirewall-cmd --reload 安装WordPress假设我们的IP、端口和安装路径如下： 1 2 domain 111.111.111.111 Port No 80 document root /usr/share/nginx/wordpress logs /usr/share/nginx/wordpress/logs 创建virtual host： 1vi /etc/nginx/conf.d/wordpress.conf 其中加入以下内容 1234567891011121314151617181920212223242526272829server &#123; listen 80; server_name 111.111.111.111; access_log /usr/share/nginx/wordpress/logs/access.log; error_log /usr/share/nginx/wordpress/logs/error.log;location / &#123; root /usr/share/nginx/wordpress; index index.php index.html index.htm;if (-f $request_filename) &#123; expires 30d; break;&#125;if (!-e $request_filename) &#123; rewrite ^(.+)$ /index.php?q=$1 last; &#125;&#125;location ~ .php$ &#123; fastcgi_pass localhost:9000; # port where FastCGI processes were spawned fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/share/nginx/wordpress$fastcgi_script_name; # same path as above fastcgi_param PATH_INFO $fastcgi_script_name; include /etc/nginx/fastcgi_params; &#125;&#125; 其中第三行，第五行，第六行和倒数第四行改为自己设定的值，按照上方的表中自己的设置来修改 接下来创建文件夹 12mkdir /usr/share/nginx/wordpressmkdir /usr/share/nginx/wordpress/logs 然后检查配置是否正确 1nginx -t 如果正确会得到以下内容 12nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 接着重启服务，并设置setenforce 1234systemctl restart nginxsystemctl restart php-fpmsetenforce 0 创建wordpress的数据库1234567mysql -u root -p# 依次执行以下操作CREATE DATABASE wordpress;CREATE USER 'wpuser'@'localhost' IDENTIFIED BY 'wppassword';GRANT ALL PRIVILEGES ON wordpress.* TO 'wpuser'@'localhost';exit 下载wordpress依次执行一下内容 1234567891011121314151617181920# 安装wgetyum -y install wget# 将内容下载到tmp中cd /tmp# 下载wget http://wordpress.org/latest.tar.gz# 解压tar -zxvf latest.tar.gz# 移动到指定目录中mv wordpress/* /usr/share/nginx/wordpress#创建指定的wp-configcp /usr/share/nginx/wordpress/wp-config-sample.php /usr/share/nginx/wordpress/wp-config.php# 修改其中的字段vi /usr/share/nginx/wordpress/wp-config.php 修改wp-config的内容原始内容 123456789// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define('DB_NAME', 'database_name_here');/** MySQL database username */define('DB_USER', 'username_here');/** MySQL database password */define('DB_PASSWORD', 'password_here');/** MySQL hostname */define('DB_HOST', 'localhost'); 改为： 123456789// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define('DB_NAME', 'wordpress');/** MySQL database username */define('DB_USER', 'wpuser');/** MySQL database password */define('DB_PASSWORD', 'wppassword');/** MySQL hostname */define('DB_HOST', 'localhost'); 然后将wordpress改为nginx的权限 1chown -R nginx:nginx /usr/share/nginx/wordpress/ 重启nginx 1systemctl restart nginx 然后访问自己的ip，就可以进入wordpress的安装界面了。 问题记录：安装时重定向过多如果出现界面显示重定向过多，则将http://Your_ip/index.php/wp-admin/install.php中的index.php删掉就可以了 问题记录：在wp-admin中修改http为https后不能访问wordpress的解决方案如果将此http修改为https后，则不能访问wordpress的各种内容。如果要修改，需要进入数据库中修改wp_options的内容。 123456789101112131415161718MariaDB [(none)]&gt; use wordpressMariaDB [wordpress]&gt; select * from wp_options where option_name = 'home';+-----------+-------------+--------------------+----------+| option_id | option_name | option_value | autoload |+-----------+-------------+--------------------+----------+| 2 | home | https://********** | yes |+-----------+-------------+--------------------+----------+1 row in set (0.00 sec)MariaDB [wordpress]&gt; select * from wp_options where option_name = 'siteurl';+-----------+-------------+--------------------+----------+| option_id | option_name | option_value | autoload |+-----------+-------------+--------------------+----------+| 1 | siteurl | https://********** | yes |+-----------+-------------+--------------------+----------+1 row in set (0.00 sec) 然后使用sql修改https为http就可以了 12update wp_options set option_value='http://*****' where option_name = 'siteurl';update wp_options set option_value='http://*****' where option_name = 'home'; 安装NextCloud创建session文件夹，并且把/var/lib/php/session的权限改为nginx 12mkdir -p /var/lib/php/sessionchown nginx:nginx -R /var/lib/php/session/ 可以看到原来session文件夹是属于apache的，后改为nginx 1234567[root@**** php]# ls -ltotal 0drwxrwx---. 2 root apache 6 Mar 7 13:37 session[root@**** php]# chown nginx:nginx -R /var/lib/php/session/[root@**** php]# ls -ltotal 0drwxrwx---. 2 nginx nginx 6 Mar 7 13:37 session 创建nextcloud的数据库使用root用户名和密码进入mysql 1mysql -u root -p 依次执行以下语句 12345create database nextcloud;create user nextclouduser@localhost identified by 'nextclouduser@';grant all privileges on nextcloud.* to nextclouduser@localhost identified by 'nextclouduser@';flush privileges;exit 生成自签名 SSL 证书（如果需要用https访问的话）运行下列指令 1234567mkdir -p /etc/nginx/cert/openssl req -new -x509 -days 365 -nodes -out /etc/nginx/cert/nextcloud.crt -keyout /etc/nginx/cert/nextcloud.keychmod 700 /etc/nginx/certchmod 600 /etc/nginx/cert/* 实例： 123456789101112131415161718192021222324252627[root@cheng php]# mkdir -p /etc/nginx/cert/[root@cheng php]# cd /etc/nginx/cert[root@cheng cert]# ls[root@cheng cert]# openssl req -new -x509 -days 365 -nodes -out /etc/nginx/cert/nextcloud.crt -keyout /etc/nginx/cert/nextcloud.keyGenerating a 2048 bit RSA private key..................................+++..........+++writing new private key to '/etc/nginx/cert/nextcloud.key'-----You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [XX]:chState or Province Name (full name) []:hbLocality Name (eg, city) [Default City]:whOrganization Name (eg, company) [Default Company Ltd]:ccOrganizational Unit Name (eg, section) []:ccCommon Name (eg, your name or your server's hostname) []:ccEmail Address []:cc[root@cheng cert]# lsnextcloud.crt nextcloud.key[root@cheng cert]# chmod 700 /etc/nginx/cert[root@cheng cert]# chmod 600 /etc/nginx/cert/* 下载Nextcloud先安装 wget 和 unzip，如果安装过则可以跳过 1yum -y install wget unzip 进入tmp目录，然后下载nextcloud 13.0.1，解压，并把文件夹移动到/usr/share/nginx/html/里面 1234cd /tmpwget https://download.nextcloud.com/server/releases/nextcloud-13.0.1.zipunzip nextcloud-13.0.1.zipmv nextcloud/ /usr/share/nginx/html/ 然后转到Nginx的web根目录，创建data文件夹 12cd /usr/share/nginx/html/mkdir -p nextcloud/data 并且更改nextcloud的目录权限 1chown nginx:nginx -R nextcloud/ 配置Nextcloud的Nginx以下给出三种配置方式，按自己所需要的来配置，我所选择的是第三种。 注意：如果使用前两种配置方式，则需要在防火墙上加入https： 12firewall-cmd --permanent --add-service=httpsfirewall-cmd --reload （1）通过 https://ip来访问:： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139upstream php-handler &#123; server 127.0.0.1:9000; #server unix:/var/run/php5-fpm.sock;&#125;server &#123; listen 80; listen [::]:80; server_name cloud.example.com; # 这里需要修改 # enforce https return 301 https://$server_name$request_uri;&#125;server &#123; listen 443 ssl http2; listen [::]:443 ssl http2; server_name cloud.example.com;# 这里需要修改 # 这里ssl需要修改 ssl_certificate /etc/ssl/nginx/cloud.example.com.crt; ssl_certificate_key /etc/ssl/nginx/cloud.example.com.key; # Add headers to serve security related headers # Before enabling Strict-Transport-Security headers please read into this # topic first. # add_header Strict-Transport-Security "max-age=15768000; # includeSubDomains; preload;"; # # WARNING: Only add the preload option once you read about # the consequences in https://hstspreload.org/. This option # will add the domain to a hardcoded list that is shipped # in all major browsers and getting removed from this list # could take several months. add_header X-Content-Type-Options nosniff; add_header X-XSS-Protection "1; mode=block"; add_header X-Robots-Tag none; add_header X-Download-Options noopen; add_header X-Permitted-Cross-Domain-Policies none; # Path to the root of your installation # 这里也需要修改，改为自己的路径，为 /usr/share/nginx/html/nextcloud/; root /var/www/nextcloud/; location = /robots.txt &#123; allow all; log_not_found off; access_log off; &#125; # The following 2 rules are only needed for the user_webfinger app. # Uncomment it if you're planning to use this app. #rewrite ^/.well-known/host-meta /public.php?service=host-meta last; #rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json # last; location = /.well-known/carddav &#123; return 301 $scheme://$host/remote.php/dav; &#125; location = /.well-known/caldav &#123; return 301 $scheme://$host/remote.php/dav; &#125; # set max upload size client_max_body_size 512M; fastcgi_buffers 64 4K; # Enable gzip but do not remove ETag headers gzip on; gzip_vary on; gzip_comp_level 4; gzip_min_length 256; gzip_proxied expired no-cache no-store private no_last_modified no_etag auth; gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy; # Uncomment if your server is build with the ngx_pagespeed module # This module is currently not supported. #pagespeed off; location / &#123; rewrite ^ /index.php$uri; &#125; location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)/ &#123; deny all; &#125; location ~ ^/(?:\.|autotest|occ|issue|indie|db_|console) &#123; deny all; &#125; location ~ ^/(?:index|remote|public|cron|core/ajax/update|status|ocs/v[12]|updater/.+|ocs-provider/.+)\.php(?:$|/) &#123; fastcgi_split_path_info ^(.+\.php)(/.*)$; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param HTTPS on; #Avoid sending the security headers twice fastcgi_param modHeadersAvailable true; fastcgi_param front_controller_active true; fastcgi_pass php-handler; fastcgi_intercept_errors on; fastcgi_request_buffering off; &#125; location ~ ^/(?:updater|ocs-provider)(?:$|/) &#123; try_files $uri/ =404; index index.php; &#125; # Adding the cache control header for js and css files # Make sure it is BELOW the PHP block location ~ \.(?:css|js|woff|svg|gif)$ &#123; try_files $uri /index.php$uri$is_args$args; add_header Cache-Control "public, max-age=15778463"; # Add headers to serve security related headers (It is intended to # have those duplicated to the ones above) # Before enabling Strict-Transport-Security headers please read into # this topic first. # add_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload;"; # # WARNING: Only add the preload option once you read about # the consequences in https://hstspreload.org/. This option # will add the domain to a hardcoded list that is shipped # in all major browsers and getting removed from this list # could take several months. add_header X-Content-Type-Options nosniff; add_header X-XSS-Protection "1; mode=block"; add_header X-Robots-Tag none; add_header X-Download-Options noopen; add_header X-Permitted-Cross-Domain-Policies none; # Optional: Don't log access to assets access_log off; &#125; location ~ \.(?:png|html|ttf|ico|jpg|jpeg)$ &#123; try_files $uri /index.php$uri$is_args$args; # Optional: Don't log access to other assets access_log off; &#125;&#125; （2）通过https://ip/nextcloud来访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131upstream php-handler &#123; server 127.0.0.1:9000; #server unix:/var/run/php5-fpm.sock;&#125;server &#123; listen 80; listen [::]:80; server_name ip; # enforce https return 301 https://$server_name$request_uri;&#125;server &#123; listen 443 ssl http2; listen [::]:443 ssl http2; server_name ip; ssl_certificate /etc/ssl/nginx/cloud.example.com.crt; ssl_certificate_key /etc/ssl/nginx/cloud.example.com.key; # Add headers to serve security related headers # Before enabling Strict-Transport-Security headers please read into this # topic first. #add_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload;"; add_header X-Content-Type-Options nosniff; add_header X-XSS-Protection "1; mode=block"; add_header X-Robots-Tag none; add_header X-Download-Options noopen; add_header X-Permitted-Cross-Domain-Policies none; # Path to the root of your installation root /var/www/; location = /robots.txt &#123; allow all; log_not_found off; access_log off; &#125; # The following 2 rules are only needed for the user_webfinger app. # Uncomment it if you're planning to use this app. # rewrite ^/.well-known/host-meta /nextcloud/public.php?service=host-meta # last; #rewrite ^/.well-known/host-meta.json # /nextcloud/public.php?service=host-meta-json last; location = /.well-known/carddav &#123; return 301 $scheme://$host/nextcloud/remote.php/dav; &#125; location = /.well-known/caldav &#123; return 301 $scheme://$host/nextcloud/remote.php/dav; &#125; location /.well-known/acme-challenge &#123; &#125; location ^~ /nextcloud &#123; # set max upload size client_max_body_size 512M; fastcgi_buffers 64 4K; # Enable gzip but do not remove ETag headers gzip on; gzip_vary on; gzip_comp_level 4; gzip_min_length 256; gzip_proxied expired no-cache no-store private no_last_modified no_etag auth; gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy; # Uncomment if your server is build with the ngx_pagespeed module # This module is currently not supported. #pagespeed off; location /nextcloud &#123; rewrite ^ /nextcloud/index.php$uri; &#125; location ~ ^/nextcloud/(?:build|tests|config|lib|3rdparty|templates|data)/ &#123; deny all; &#125; location ~ ^/nextcloud/(?:\.|autotest|occ|issue|indie|db_|console) &#123; deny all; &#125; location ~ ^/nextcloud/(?:index|remote|public|cron|core/ajax/update|status|ocs/v[12]|updater/.+|ocs-provider/.+)\.php(?:$|/) &#123; fastcgi_split_path_info ^(.+\.php)(/.*)$; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param HTTPS on; #Avoid sending the security headers twice fastcgi_param modHeadersAvailable true; fastcgi_param front_controller_active true; fastcgi_pass php-handler; fastcgi_intercept_errors on; fastcgi_request_buffering off; &#125; location ~ ^/nextcloud/(?:updater|ocs-provider)(?:$|/) &#123; try_files $uri/ =404; index index.php; &#125; # Adding the cache control header for js and css files # Make sure it is BELOW the PHP block location ~ \.(?:css|js|woff|svg|gif)$ &#123; try_files $uri /nextcloud/index.php$uri$is_args$args; add_header Cache-Control "public, max-age=15778463"; # Add headers to serve security related headers (It is intended # to have those duplicated to the ones above) # Before enabling Strict-Transport-Security headers please read # into this topic first. # add_header Strict-Transport-Security "max-age=15768000; # includeSubDomains; preload;"; add_header X-Content-Type-Options nosniff; add_header X-XSS-Protection "1; mode=block"; add_header X-Robots-Tag none; add_header X-Download-Options noopen; add_header X-Permitted-Cross-Domain-Policies none; # Optional: Don't log access to assets access_log off; &#125; location ~ \.(?:png|html|ttf|ico|jpg|jpeg)$ &#123; try_files $uri /nextcloud/index.php$uri$is_args$args; # Optional: Don't log access to other assets access_log off; &#125; &#125;&#125; 注意：修改内容同第一条，但是在安装路径方面有所区别，我们nextcloud的安装路径还是/usr/share/nginx/html/nextcloud/，但是如果需要用https://ip/nextcloud来访问nextcloud，则在此配置文件中，root选项不能带上nextcloud，需要使用root /usr/share/nginx/html/;。如果使用root /usr/share/nginx/html/nextcloud/;则会出现file not found的错误。下面第三条配置同理。 （3）通过http://ip/nextcloud来访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120upstream php-handler &#123; server 127.0.0.1:9000; #server unix:/var/run/php5-fpm.sock;&#125;server &#123; listen 80; listen [::]:80; server_name ip; # Add headers to serve security related headers # Before enabling Strict-Transport-Security headers please read into this # topic first. #add_header Strict-Transport-Security "max-age=15768000; includeSubDomains; preload;"; add_header X-Content-Type-Options nosniff; add_header X-XSS-Protection "1; mode=block"; add_header X-Robots-Tag none; add_header X-Download-Options noopen; add_header X-Permitted-Cross-Domain-Policies none; # Path to the root of your installation root /var/www/; location = /robots.txt &#123; allow all; log_not_found off; access_log off; &#125; # The following 2 rules are only needed for the user_webfinger app. # Uncomment it if you're planning to use this app. # rewrite ^/.well-known/host-meta /nextcloud/public.php?service=host-meta # last; #rewrite ^/.well-known/host-meta.json # /nextcloud/public.php?service=host-meta-json last; location = /.well-known/carddav &#123; return 301 $scheme://$host/nextcloud/remote.php/dav; &#125; location = /.well-known/caldav &#123; return 301 $scheme://$host/nextcloud/remote.php/dav; &#125; location /.well-known/acme-challenge &#123; &#125; location ^~ /nextcloud &#123; # set max upload size client_max_body_size 512M; fastcgi_buffers 64 4K; # Enable gzip but do not remove ETag headers gzip on; gzip_vary on; gzip_comp_level 4; gzip_min_length 256; gzip_proxied expired no-cache no-store private no_last_modified no_etag auth; gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy; # Uncomment if your server is build with the ngx_pagespeed module # This module is currently not supported. #pagespeed off; location /nextcloud &#123; rewrite ^ /nextcloud/index.php$uri; &#125; location ~ ^/nextcloud/(?:build|tests|config|lib|3rdparty|templates|data)/ &#123; deny all; &#125; location ~ ^/nextcloud/(?:\.|autotest|occ|issue|indie|db_|console) &#123; deny all; &#125; location ~ ^/nextcloud/(?:index|remote|public|cron|core/ajax/update|status|ocs/v[12]|updater/.+|ocs-provider/.+)\.php(?:$|/) &#123; fastcgi_split_path_info ^(.+\.php)(/.*)$; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param HTTPS on; #Avoid sending the security headers twice fastcgi_param modHeadersAvailable true; fastcgi_param front_controller_active true; fastcgi_pass php-handler; fastcgi_intercept_errors on; fastcgi_request_buffering off; &#125; location ~ ^/nextcloud/(?:updater|ocs-provider)(?:$|/) &#123; try_files $uri/ =404; index index.php; &#125; # Adding the cache control header for js and css files # Make sure it is BELOW the PHP block location ~ \.(?:css|js|woff|svg|gif)$ &#123; try_files $uri /nextcloud/index.php$uri$is_args$args; add_header Cache-Control "public, max-age=15778463"; # Add headers to serve security related headers (It is intended # to have those duplicated to the ones above) # Before enabling Strict-Transport-Security headers please read # into this topic first. # add_header Strict-Transport-Security "max-age=15768000; # includeSubDomains; preload;"; add_header X-Content-Type-Options nosniff; add_header X-XSS-Protection "1; mode=block"; add_header X-Robots-Tag none; add_header X-Download-Options noopen; add_header X-Permitted-Cross-Domain-Policies none; # Optional: Don't log access to assets access_log off; &#125; location ~ \.(?:png|html|ttf|ico|jpg|jpeg)$ &#123; try_files $uri /nextcloud/index.php$uri$is_args$args; # Optional: Don't log access to other assets access_log off; &#125; &#125;&#125; 注意：此条配置删除了关于ssl的配置和转发到https的内容，其他修改内容和注意事项同第一条和第二条。 为 Nextcloud 配置 SELinux 和 FirewallD 规则以强制内容运行SELinux：先安装SELinux管理工具 1yum -y install policycoreutils-python 然后运行一下命令，如果nextcloud的安装目录与下面不一样，则所需要做修改 12345678semanage fcontext -a -t httpd_sys_rw_content_t '/usr/share/nginx/html/nextcloud/data(/.*)?'semanage fcontext -a -t httpd_sys_rw_content_t '/usr/share/nginx/html/nextcloud/config(/.*)?'semanage fcontext -a -t httpd_sys_rw_content_t '/usr/share/nginx/html/nextcloud/apps(/.*)?'semanage fcontext -a -t httpd_sys_rw_content_t '/usr/share/nginx/html/nextcloud/assets(/.*)?'semanage fcontext -a -t httpd_sys_rw_content_t '/usr/share/nginx/html/nextcloud/.htaccess'semanage fcontext -a -t httpd_sys_rw_content_t '/usr/share/nginx/html/nextcloud/.user.ini'restorecon -Rv '/usr/share/nginx/html/nextcloud/' 在浏览器中安装Nextcloud按照nextcloud的nginx配置，在浏览器中输入对应的地址。然后选择mysql，将nextcloud数据库的用户名和密码填写好安装就可以了。 参考 https://docs.nextcloud.com/ https://www.howtoforge.com/tutorial/how-to-install-nextcloud-with-nginx-and-php-fpm-on-centos-7/ https://www.itzgeek.com/web/wordpress/install-wordpress-with-nginx-1-6-on-centos-7-rhel-7.html]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>wordpress</tag>
        <tag>nextcloud</tag>
        <tag>nginx</tag>
        <tag>mysql</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS Python2与Python3 安装 OpenCV3]]></title>
    <url>%2F2017%2F12%2F08%2F2017-12-9-MacOS-Python2%E4%B8%8EPython3-%E5%AE%89%E8%A3%85-OpenCV3%2F</url>
    <content type="text"><![CDATA[MacOS Python2与Python3 安装 OpenCV3主要参考网址：https://www.pyimagesearch.com/2016/12/19/install-opencv-3-on-macos-with-homebrew-the-easy-way/ Mac环境和Python环境：MacOS Sierra 10.12.6 Python版本： ​ 自带Python 2.7.10 ​ 自带Python 2.6.9 ​ 之前安装Python3.6.3 安装 homebrew首先在mac上安装Command Line Tools for Xcode 在终端输入 1xcode-select --install 然后按要求安装。 接下来安装 Homebrew： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装完成使用which检测是否安装成功 如下图： 检查电脑中的python版本如果Python路径不对，会产生很多问题 关于Mac中Python版本、安装位置介绍电脑自带Python 2.7环境： /System/Library/Frameworks/Python.Framework/Versions/2.7/bin/python2.7 Mac自带Python 2.6环境： /System/Library/Frameworks/Python.Framework/Versions/2.6/bin/python2.6 用户安装的Python 3.6所在目录 /Library/Frameworks/Python.framework/Version/3.6 为了使OpenCV顺利安装，选择删除上次安装的Python3，使用brew来重新安装Python3 使用这里的方法来删除自带Python3 成功后电脑中只有Mac本身自带的Python2.7和2.6 使用brew重新安装Pyhton2与Python31$ brew install python python3 安装好之后可以使用 12$ which python$ which pyhton3 来查看python是否安装完成。后发现python还是使用系统自带的python目录，于是在~/.bash_profile中添加以下内容export PATH=&quot;/usr/local/opt/python/libexec/bin:$PATH&quot;，然后再使用 which python就会返回自带安装的Python 如果 12$ which python$ which pyhton3 都是使用brew安装的位置，就可以进行下一步，安装opencv3 安装opencv3首先添加 homebrew/science $ brew tap homebrew/science 接着使用 1brew install opencv3 --with-contrib --with-python3 –with-contrib : This ensures that the opencv_contrib repository is installed, giving us access to additional, critical OpenCV features such as SIFT, SURF, etc. –with-python3 : OpenCV 3 + Python 2.7 bindings will be automaticallycompiled; however, to compile OpenCV 3 + Python 3 bindings we need to explicitly supply the –with-python3 switch. 等待安装完成 关联Python2 与 OpenCV3找到OpenCV3 — python2 的位置 /usr/local/opt/opencv/lib/python2.7/site-packages 可能每台电脑不一样，大概就是这个目录 然后使用 1$ echo /usr/local/opt/opencv3/lib/python2.7/site-packages &gt;&gt; /usr/local/lib/python2.7/site-packages/opencv3.pth 来关联Python2 与OpenCV3 完成之后对Python2进行检测 关联Python3 与 OpenCV3同样，找到OpenCV3 — python3的位置 /usr/local/opt/opencv3/lib/python3.6/site-packages/ 发现 cv2.so 的名字不一样，于是先改名字 12$ cd /usr/local/opt/opencv3/lib/python3.6/site-packages/$ mv cv2.cpython-36m-darwin.so cv2.so 然后再次使用 1$ echo /usr/local/opt/opencv/lib/python3.6/site-packages &gt;&gt; /usr/local/lib/python3.6/site-packages/opencv3.pth 来关联Python3 与 OpenCV3 完成之后进行检测 完成安装！]]></content>
      <categories>
        <category>Python</category>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 模块与导入 import机制解析]]></title>
    <url>%2F2017%2F11%2F05%2F2017-11-05-Python-%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Python 模块在Python中，导入并不是把一个文本文件插入另一个文本文件中。导入其实是运行时的运算，程序第一次导入指定文件时，会执行三个步骤。 大致过程分为三步： 找到模块文件 编译成位码（需要时） 执行模的代码来创建其所定义的对象 这三个步骤只会在程序执行时，模块第一次导入时才会进行。在这之后，导入相同模块时，会跳过这三个步骤，而只是提取内存中已加载的模块对象。 模块导入过程从技术上讲，详细过程为： Python在初始化运行环境的时候会预先加载一批内建模块到内存中，这些模块的相关信息被存放在modules中。导入sys模块后在Python解释器中输入sys.modules.items()便可显示所有预加载模块的相关信息。当加载一个模块的时候，解释器实际上要完成以下工作 找到模块路径，在后面详细解释 在sys.modules中搜索看看该模块是否已经存在，如果存在，则将其导入到当前局部命名空间，加载结束。 如果在sys模块中找不到对应模块的名称，则为需要导入的模块创建一个字典对象，并将该对象插入sys.modules中。 加载前确认是否需要对模块对应的文件进行编译。如果有必要，Python接下来会将其编译为字节码。Python会检查文件的时间戳，如果发现字节码文件比源代码文件旧（例如修改过源文件），就会在程序运行时重新生成字节代码。 执行动态加载，在当前模块的命名空间中执行编译后的字节码。文件中的所有语句会依次执行，从头到尾。 PS. 当文件被导入时，就会进行编译。因此，通常不会看见程序顶层文件的.pyc字节码文件，除非这个文件也被其他文件导入：只有被导入的文件才会在机器上留下.pyc。顶层文件的字节码实在内部使用之后就丢弃了；被导入文件的字节码侧保存在文件中从而可以提高导入之后的速度。 模块搜索路径导入过程最重要的部分是最早的部分，也就是定位要导入的文件。 Python的模块搜索路径是一些主要组件组合而成的结果。 程序的主目录 Python的主目录（如果进行了设置） 标准链接库目录 任何.pth文件的内容（如果存在的话） 最后，这四个组件组合起来就成了sys.path。 Q&amp;A模块源代码是怎么变成模块对象的： 模块的源代码文件在导入时，就会自动生成模块文件。从技术角度讲，模块的源代码会在导入时运行，一次一条语句，而在这个过程中赋值的所有变量名都会生成模块对象的属性。 为什么需要设置PYTHONPATH环境变量： PATHONPATH是设置包含Python程序文件的目录列表。只需设置PYTHONPATH，从而可以正在用的目录以外的其他目录进行导入（正在使用的目录可以是交互模式下使用的当前目录，或者包含顶层文件的目录） 什么是命名空间： 命名空间是一种独立完备的变量包，而变量就是命名空间对象的属性。模块的命名空间包含了代码在模块文件顶层赋值的所有变量名（也就是没有嵌套于def或class语句中）。从技术角度讲，模块的全局作用域会变成模块对象的属性命名空间。 模块的使用导入只发生一次在默认情况下，Python只对每个文件的每个进程做一次导入操作，之后的导入操作都只会取出已加载的模块对象。 123# simple.pyprint 'hello'spam = 1 123456789&gt;&gt;&gt;import simplehello&gt;&gt;&gt;simple.spam1&gt;&gt;&gt;simple.spam = 2&gt;&gt;&gt;import spam&gt;&gt;&gt;spam.spam2 如果需要一个模块的代码通过某种导入后再一次运行，使用内置load函数 在Python3中，需要使用 import imp来使用load import 和 from是赋值语句import 使一个变量名引用整个模块对象 from 会把变量名复制到另一个作用域，所以它就可以让我们直接在脚本中使用复制后的变量名，而不需要通过模块 from * 会取得模块顶层所有赋了值的变量名的拷贝 import 和 from 的对等性from只是把变量名从一个模块复制到另一个模块，并不会对模块名本身进行赋值 从概念上说，一个from语句： 1from module import name1, name2 与下面这些语句是等效的 1234import moudlename1 = module.name1name2 = module.name2del module from 语句会在导入者中创建新变量，而那些变量初始化时引用了导入文件中的同名对象。不过，只有变量名被复制出来，而非模块本身。 from 的第一步骤也是普通的导入操作。因此，from总是会把整个模块导入到内存中（如果还没被导入），无论是从这个文件中复制出多少变量名。只加载模块文件的一部分（例如一个函数）是不可能的，但是因为模块在Python之中是字节码而不是机器码，通常可以忽略效率问题。 有节制的使用from语句命名空间冲突若三个文件 a.py, b.py, importtest.py 其中 a.py, b.py中定义了 add()函数，在importtest中同时使用 from 引用 a.py 和 b.py 的 add()函数，并输出。 最后输出显示最后起作用的是最近导入的add() 在项目中，特别是大型项目中频繁使用from会增加命名空间冲突的概率从而导致无法预料的问题。 循环嵌套导入的问题123456789#c1.pyfrom c2 import gdef x(): pass#c2.pyfrom c1 import xdef g(): pass 无论运行哪个文件都会抛出ImportError异常。 解决循环嵌套导入问题的一个方法是使用import语句。 模块命名空间模块语句会在首次导入时执行系统中，模块在第一次导入时无论在什么地方，Python都会建立空的模块对象，并逐一执行该模块文件内的语句，依照文件从头到尾的顺序 顶层的赋值语句会创建模块属性在导入时，文件顶层（不在def或class中）赋值变量的语句（例如 = 和 def），会创建模块对象的属性，赋值的变量名会储存在模块的命名空间中。 ps: 模块的属性都是在模块语句执行时赋值的 之后导入只会使用已加载的模块对象，而不会重载或重新执行文件的代码 Q&amp;Afrom与import有什么关系： from语句是导入整个模块，就像import语句那样，但是还有个步骤，就是会从被导入的模块中，复制一个或多个变量到from语句所在的作用域中。这样可以让程序员直接使用被导入的变量名。而不是通过模块来使用变量名。 __name__和__main__如果文件是以顶层程序文件执行，在启动时，__name__就会设置为字符串”__main__“ 如果文件被导入，__name__就会改成客户端所了解的模块名]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>import</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《改善Python程序的91个建议》笔记]]></title>
    <url>%2F2017%2F10%2F11%2F2017-11-05-%E3%80%8A%E6%94%B9%E5%96%84Python%E7%A8%8B%E5%BA%8F%E7%9A%8491%E4%B8%AA%E5%BB%BA%E8%AE%AE%E3%80%8B-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《改善Python程序的91个建议》笔记第二章：编程惯用法开始 没有包括的内容8、10、12、13、14、18 数据交换值不推荐使用中间变量x, y = y, x 内存执行顺序 1）计算右边表达式 y,x，在内存中创建元组 (y,x) 2）计算表达式左边的值并且赋值。元组被一次分配给左边的标识符xy 使用enumerate()获取序列迭代索引和值123li = ['a', 'b', 'c', 'd']for i, e in enumerate(li): print 'index : ', i, 'element : ', 'e' enumerate实现原理 yield:12345def enumerate(sequence, start = 0): n = start for elem in sequence: yield n, elem n += 1 enumerate 不适合字典迭代12345678910111213141516&gt;&gt;&gt; person_info = &#123;'name':'John', 'age':'20', 'hobby':'football'&#125;&gt;&gt;&gt; for k, v in enumerate(person_info):... print k, v...0 hobby1 age2 name&gt;&gt;&gt;&gt;&gt;&gt; for k, v in person_info.iteritems():... print k, v...hobby footballage 20name John 使用enumerate不会报错的原因是因为字典默认被转换为了序列进行处理，若要对字典进行迭代，使用dict.iteritems() 分清 is 和 ==123456789101112&gt;&gt;&gt; a = 2&gt;&gt;&gt; b = 2&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; b == bTrue&gt;&gt;&gt; c = 299&gt;&gt;&gt; d = 299&gt;&gt;&gt; c is dFalse&gt;&gt;&gt; c == dTrue 原因是因为Python的小整数池，同理还有Python的小字符串。具体原因请看Python源码剖析。 is 与 == 的区别两种操作的意义 操作符 意义 is object identity == equal is表示的是对象标识符。而 == 表示的是值是否相等 is方法相当于调用is(a) == is(b) == 方法相当于调用 a.__eq__(b) 考虑兼容性，尽量使用 Unicode关于str和unicode请看博客Python编码问题 在Python2中通过使用 import unicode_literals自动将普通字符串识别为Unicode字符串，这样字符串行为与Python3保持一致 12345678&gt;&gt;&gt; from __future__ import unicode_literals&gt;&gt;&gt; s = '中文'&gt;&gt;&gt; su'\u4e2d\u6587'&gt;&gt;&gt; s.encode('utf-8')'\xe4\xb8\xad\xe6\x96\x87'&gt;&gt;&gt; print s.encode('utf-8')中文 深入理解None，正确判断对象是否为空常量None的特殊性体现在它既不是0，False，也不是空字符串。它就是一个空值对象。其数据类型为NoneType，遵循单例模式，是唯一的，因而不能创建None对象。所有赋值None的变量都相等。并且None和其他非None的对象比较结果都为False。 连接字符串应优先使用join而不是+使用join()方法的效率要高于+操作符。因为使用S1 + S2 + S3 + S4，执行一次+操作就会在内存中申请一块新的内存空间。并将上一次操作结果和本次操作的右操作数复制到新申请的内存空间中。执行N个字符串的连接操作，就会产生N-1个中间结果，每产生一个中间结果就要申请和复制一块内存。+操作的时间复杂度为O(n ^2)。 join方法连接字符串时，会先计算需要申请的总的内存空间。然后一次性申请所需内容并将字符串序列中每一个元素复制到内存中去，所以join操作的时间复杂度为O(n)]]></content>
      <categories>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 闭包与装饰器]]></title>
    <url>%2F2017%2F10%2F11%2F2017-11-04-Python-%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Python 闭包 装饰器Python创建、改变或查找变量名都是在所谓的命名空间（一个保存变量名的地方）中进行的。 Python变量名解析（LEGB原则）当在函数中使用未认证的变量名时，Python搜索4个作用域： 本地作用域（Local）、上层结构中的def或lambda的本地作用域（Enclosing）、全局作用域（Global）、内置作用域（Built-in0） 在第一处能够找到这个变量名的地方停下来。如果变量名在这次搜索中没有找到，Python会报错。 Global语句：全局变量如果是在函数内部被赋值，必须经过global声明 闭包（closure）如果在一个内嵌函数中，对外部函数的变量（而不是全局作用域变量）进行引用，那么这种行为称为闭包或工厂函数。 例子123456789101112&gt;&gt;&gt; def maker(n):... def action(x):... return x ** n... return action...&gt;&gt;&gt; f = maker(2)&gt;&gt;&gt; f&lt;function action at 0x108e581b8&gt;&gt;&gt;&gt; f(3)9&gt;&gt;&gt; f(4)16 定义外部函数maker，生成并返回一个简单的嵌套函数，但是并不调用内嵌函数。 然后将 2 作为参数传递给 maker。并将内部函数 action 赋值给 f。调用f(3)会直接生成 9 也就是说，maker函数内部的名为action的函数，作为内嵌函数记住了整数 2，即maker函数内部的变量 n的值。尽管在调用执行 f 时 maker 已经返回了值并且退出。但是在本地作用域的 n 被作为执行的状态信息保留了下来。 在python函数中，可以直接引用外部变量，但是不能改写外部变量。因此如果在闭包中直接改写父函数的变量。就会发生错误，通常使用列表代替。例：闭包计数器 1234567891011121314&gt;&gt;&gt; def counter(start):... count = [start]... def increase():... count[0] += 1... return count... return increase...&gt;&gt;&gt; count = counter(5)&gt;&gt;&gt; count()[6]&gt;&gt;&gt; count()[7]&gt;&gt;&gt; count()[8] 错误调用闭包中的返回函数不要引用循环变量 123456789101112def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()f1() # 9f2() # 9f3() # 9 当开始调用 f1, f2, f3时，循环变量中的 i 早已变成 3]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>闭包</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 编码]]></title>
    <url>%2F2017%2F10%2F11%2F2017-10-11-Python-%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Python2编码问题Unicode为了适合当地语言和字符，设计和实现类似GB2312/GBK/GB18030/BIG5的编码方案。这样各搞一套，在本地使用没有问题，一旦出现在网络中，由于不兼容，互相访问就出现了乱码现象。 举个例子： 在西方国家的EASCII之中，如果一个8b的数字用来表示一个字符，当最高位是1的时候，它表示一个拉丁字符等其他特殊字符；但是中文编码GB2312却规定，两个8b的字符，如果高位为1，那么它表示一个汉子。具体而言，“1111，0111；1111，0111”使用EASCII表示两个约等号，使用GB2312解码却表示一个汉子：也就是说，同样的存储，用不同的编码方案来解码，得到的结果不同。另外一个方面，同样对于“约等于号”，GB2312给它的编码是A1D006：对于同样的字符，不同的字符集有不同的编码。 为了解决这个问题，一个伟大的创想产生了——Unicode。Unicode编码系统为表达任意语言的任意字符而设计。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个数字代表唯一的至少在某种语言中使用的符号。（并不是所有的数字都用上了，但是总数已经超过了65535，所以2个字节的数字是不够用的。）被几种语言共用的字符通常使用相同的数字来编码，除非存在一个在理的语源学(etymological)理由使不这样做。不考虑这种情况的话，每个字符对应一个数字，每个数字对应一个字符。即不存在二义性。不再需要记录”模式”了。U+0041总是代表’A’，即使这种语言没有’A’这个字符。 Unicode是字符集，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。 Python中的编码Python中的字符串有两种表示方式：str和unicode 对应密码领域：unicode为明文密码，str为不同加密方式方式的暗码。不同的加密方式对应的就是不同的编码方案。如ASCII、GBK、UTF-8等。 文件开头的 # coding = utf-8若是在Python文件开头不带上这句注释： 12string = '中国'print 'string type : ', type(string), ', string : ', string 会发现编译器报错：SyntaxError: Non-ASCII character ‘\xe4’ in file …coding.py on line 3, but no encoding declared; 这是因为不指定文件的编码方式，则会按照Python中的defaultencoding(ASCII)来进行文件编码，又因为ASCII不能识别中文，所以会报错。在开头加上注释 #coding = utf-8便能解决问题。 若是在开头指定了coding = utf-8，则此文件所有的str字符串全部为utf-8格式。若是想解码为unicode，则需要使用str.decode(&quot;utf-8&quot;)， 不指定则为ASCII encode和decodeencode：编码 decode：解码 在Python中，str转化为unicode称为解码，unicode转化为str称为编码。 def encode(self, encoding=None, errors=None) def decode(self, encoding=None, errors=None) 解码为unicodestr具有不同的编码，若是想要解码为unicode，则必须知道当前str的编码。（英文可直接使用str.decode()）若字符串中带有中文字符而直接使用str.decode(),则会报错’ascii’ codec can’t decode byte 0xe4 in position 0: ordinal not in range(128)，因为Python默认编码为ASCII，不能处理中文字符，而英文不受ASCII编码的限制。 123456789# coding:utf-8string = '中国'# 正确的处理方法string2 = string.decode('utf-8')# 错误的处理方法string3 = string.decode('utf-8') 不同编码的str互相转换]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>字符串</tag>
        <tag>编码</tag>
        <tag>unicode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 迭代]]></title>
    <url>%2F2017%2F09%2F11%2F2017-09-11-Python-%E8%BF%AD%E4%BB%A3%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Python 迭代(一)容器（container）容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。通常这类数据结构把所有的元素存储在内存中（也有一些特例，并不是所有的元素都放在内存，比如迭代器和生成器对象）。在Python中，常见的容器对象有： list, deque … set, frozensets … dice, defaultdice, OrderedDict, Counter … tuple, namedtuple … str 从技术角度来说，当它可以用来询问某个元素是否包含在其中时，那么这个对象就可以认为是一个容器，比如 list，set，tuples都是容器对象： 1234assert 1 in [1, 2, 3]assert 4 not in [1, 2, 3]assert 1 in &#123;1, 2, 3&#125;assert 1 in (1, 2, 3) dict： 123d = &#123;1:'foo', 2:'bar', 3:'qux'&#125;assert 1 in dassert 'foo' not in d str: 123s = 'foobar'assert 'b' in sassert 'x' not in s 可迭代对象（iterable）很多容器都是可迭代对象，此外还有更多的对象同样也是可迭代对象，比如处于打开状态的files，sockets等等。但凡是可以返回一个迭代器的对象都可称之为可迭代对象，听起来可能有点困惑，没关系，先看一个例子： 12345678x = [1, 2, 3]y = iter(x)z = iter(x)next(y) # 1next(y) # 2next(z) # 1type(x) # &lt;class 'list'&gt;type(y) # &lt;class 'list_iterator'&gt; 这里x是一个可迭代对象，可迭代对象和容器一样是一种通俗的叫法，并不是指某种具体的数据结构，list是可迭代对象，dict是可迭代对象，set也是可迭代对象。y和z是两个独立的迭代器，迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。迭代器有一种具体的迭代器类型，比如list_iterator，set_iterator。可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。 迭代器（iterator)它是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器，__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常，至于它们到底是如何实现的这并不重要。 Python中的迭代器为什么要实现__iter__方法 所以，迭代器就是实现了工厂模式的对象，它在你每次你询问要下一个值的时候给你返回。有很多关于迭代器的例子，比如itertools函数返回的都是迭代器对象。 生成无限序列： 12345678&gt;&gt;&gt; from itertools import count&gt;&gt;&gt; counter = count(start = 13)&gt;&gt;&gt; next(counter)13&gt;&gt;&gt; next(counter)14&gt;&gt;&gt; counter.next()15 从有限序列中生成无限序列 12345678910&gt;&gt;&gt; from itertools import cycle&gt;&gt;&gt; colors = cycle(['red', 'blue', 'green'])&gt;&gt;&gt; next(colors)'red'&gt;&gt;&gt; next(colors)'blue'&gt;&gt;&gt; colors.next()'green'&gt;&gt;&gt; colors.next()'red' 从无限序列生成有限序列 12345678910&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; colors = cycle(['red', 'blue', 'green'])&gt;&gt;&gt; limit = islice(colors, 0, 4)&gt;&gt;&gt; for x in limit:... print(x)...redbluegreenred 自定义迭代器（斐波那契） 12345678910111213141516&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; class Fib:... def __init__(self):... self.prev = 0... self.curr = 1... def __iter__(self):... return self... def next(self):... value = self.curr... self.curr += self.prev... self.prev = value... return value...&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; list(islice(f, 0, 10))[1, 1, 2, 3, 5, 8, 13, 21, 34, 55] Fib既是一个可迭代对象（因为它实现了__iter__方法），又是一个迭代器（因为实现了__next__方法）。实例变量prev和curr用户维护迭代器内部的状态。每次调用next()方法的时候做两件事： 1、为下一次调用next()方法修改状态 2、为当前这次调用生成返回结果 迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。 ##生成器 生成器算得上是Python语言中最吸引人的特性之一，生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。它不需要再像上面的类一样写__iter__()和__next__()方法了，只需要一个yiled关键字。 生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。用生成器来实现斐波那契数列的例子是： ###生成器函数 12345678910&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; def fib():... prev, curr = 0, 1... while True:... yield curr... prev, curr = curr, curr + prev...&gt;&gt;&gt; f = fib()&gt;&gt;&gt; list(islice(f, 0, 10))[1, 1, 2, 3, 5, 8, 13, 21, 34, 55] 解释生成器函数的执行顺序 使用函数时：f = fib()，并不执行任何代码，而是返回一个迭代器。 当第一次调用next()函数时，从函数入口开始执行进行初始化。然后进入循环，当碰到yield定义时返回，生成当前值。当再次调用next()函数时，从yield定义的下一句开始执行，直到第二次循环碰到yield定义返回。依次往下，直到循环结束。 解释 a, b = b, a + b 执行过程 将 b, a+b转换为一个元组，然后将元组中的值赋给ab 123456789# python 中 a, b = b, a + b 的执行过程&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; c = b, a + b&gt;&gt;&gt; print c(2, 3)&gt;&gt;&gt; a, b = c&gt;&gt;&gt; print a, b2 3 fib就是一个普通的python函数，它特殊的地方在于函数体中没有return关键字，函数的返回值是一个生成器对象。当执行f=fib()返回的是一个生成器对象，此时函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。 生成器在Python中是一个非常强大的编程结构，可以用更少地中间变量写流式代码，此外，相比其它容器对象它更能节省内存和CPU，当然它可以用更少的代码来实现相似的功能。现在就可以动手重构你的代码了，但凡看到类似： 12345def something(): result = [] for x in ...: result.append(x) return result 的代码。都可以用生成器函数来代替： 123def iter_something(): for x in ...: yield x 生成器表达式先来看列表推导式 List comprehensions 12[i for i in range(10) if i % 2 == 0]# [0, 2, 4, 6, 8] Python风格的语法的另一个典型例子是使用enumerate。这个内建函数在循环中提供了更加便利的获得索引的方式 1234567&gt;&gt;&gt; seq = ['one', 'two', 'three']&gt;&gt;&gt; for i , ele in enumerate(seq):... print i, ele...0 one1 two2 three 然后，使用List comprehensions重构 123456&gt;&gt;&gt; def _tre(pos, element):... return '%d : %s' % (pos, element)...&gt;&gt;&gt; seq = ['one', 'two', 'three']&gt;&gt;&gt; [_tre(i, e) for i, e in enumerate(seq)]['0 : one', '1 : two', '2 : three'] 列表推导式被封装到一个列表中，所以很明显它能立即生成一个新列表。但是列表推导式也有一些负面效应，那就是整个列表必须一次性加载与内存之中。针对这个问题，生成器（Generator）能很好的解决。生成器表达式不会一次将整个列表加载到内存中，而是生成一个生成器对象，所以一次只加载一个列表元素。 生成器表达式是列表推倒式的生成器版本，看起来像列表推导式，但是它返回的是一个生成器对象而不是列表对象。 12345&gt;&gt;&gt; a = (x*x for x in range(10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x401f08&gt;&gt;&gt;&gt; sum(a)285 itertools模块用法见Python文档 https://docs.python.org/2.7/library/itertools.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>迭代器</tag>
        <tag>可迭代对象</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码]]></title>
    <url>%2F2017%2F09%2F04%2F2017-09-04-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码状态码如 200 OK，以3位数字和原因短语组成 类别 原因短语 1XX Informational （信息性状态码） 接受的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 2XX 成功请求正常处理 200 OK表示从客户端发来的请求在服务器端被正确处理 204 No Content请求已处理成功，但在返回的响应报文中不含实体的主体部分 一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用 206 Partial Content该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range制定范围的实体内容 3XX 重定向表明浏览器需要执行某些特殊的处理以正确处理请求 301 Moved Permanently永久重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI 像下方给出的请求URI，当指定资源路径最后忘记添加斜杠“/”，就会产生301状态码 http://example.com/sample 302 Found临时重定向。该状态码表示说请求的资源已经分配了新的URI，希望用户（本次）能使用新的URI访问 和301 Move Permanently状态码相似，但302状态码代表的资源不是永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，二十仍然保留返回302状态码的页面对应的URI 303 See Other该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。 303状态码和302Found状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。 304 Not Modified该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但为满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。 307 Temporary Redirect临时重定向。该状态码与302 Found有着相同的含义。尽管302标准禁止POST变换为GET，但实际使用时大家并不遵守。 4XX客户端错误400 Bad Request该状态码表示请求报文中存在语法错误。当发生错误时，需修改请求的内容后再次发送请求。另外，浏览器会像200 OK一样对待该状态码 401 Unauthoirized该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过一次请求，则表示用户认证失败。 返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python list 操作时间复杂度]]></title>
    <url>%2F2017%2F07%2F23%2F2017-07-23-Python-List-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[python list操作不改变数据的操作 Operation Running Time len(data) O(1) data[j] O(1) data.count(value) O(n) data.index(value) O(k + 1) value in data O(k + 1) data1 == data2 O(k + 1) data[j:k] O(k - j + 1) data1 + data2 O(n1 + n2) c * data O(cn) 修改数据的操作 Operation Running Time data[j] = val O(1) data.append(value) O(1)* data.insert(k, value) O(n - k + 1)* data.pop() O(1) data.pop(k) del data[k] O(n - k) * data.remove(value) O(n)* data1.extend(data2) O(n2)* data.reverse() O(n) data.sort() O(nlogn) 关于Python的sorted和sortsorted返回一个新的排序完成的对象 sort返回None，直接改变对象本身 Composing Strings123456# WARNING : Do not do this# O(n^2)letters = ''for c in document: if c.isalpha(): letters += c 123456# O(n)temp = []for c in document: if c.isalpha(): temp.append(c)letters = ''.join(temp) 12345letters = ''.join([c for c in document if c.isalpha()])# avoid the temporary list with a generator comprehension:letters = ''.join(c for c in document if c.isalpha())]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>时间复杂度</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新版方正教务系统爬虫]]></title>
    <url>%2F2017%2F06%2F02%2F2017-06-02-%E6%96%B0%E7%89%88%E6%96%B9%E6%AD%A3%E6%95%99%E5%8A%A1%E5%A4%84%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[新版方正教务系统爬虫 技术 解释 Python 2.7 BeautifulSoup 4.X Pycharm 2017 Firefox … Firebug … 新版教务处地址 218.199.228.43 基本原理GET请求12345678910import urllib2# 确定要访问的页面地址url = 'http://****?a=1&amp;b=2'# 构造 request 请求request = urllib2.Request(url)# 返回 response 响应response = urllib2.urlopen(request)# 打印输出结果 html页面result = response.read()print result POST请求1234567891011121314151617181920import urllibimport urllib2data=&#123; username = 'your username' passwd = 'your password'&#125;# 确定登录页面 -- 根据请求确定url = 'http://******'# 确定请求头 -- request 的请求头信息请参考 http解析headers = &#123; 'User-Agent':... 'Cookie':... 'Referer':...&#125;encoded_data = urllib.urlencode(data)request = urllib2.Request(url=url, data=encoded_data, headers=headers)response = urllib2.urlopen(request)result = response.read()print result 模拟登录获得登录url根据地址栏的url进行登录，发现并不能成功，总是返回登录界面。使用Firebug进行抓包分析。 发现真正的登陆url为 http://218.197.80.13/xtgl/login_login.html。并且登录会对cookie进行检查，选择 cookielib.CookieJar() 进行cookie操作，具体代码 1234567891011121314151617181920212223242526272829303132def __init__(self): # 通过登录后获取 cookie self.cookie = '' # 获得模拟登陆后的url self.res_url = '' # 设置登录成功后的请求头中的Referer self.referer = '' # 定义登陆url self.login_url = 'http://218.197.80.13/xtgl/login_login.html' # 定义cookie self.cj = cookielib.CookieJar() # 定义用户名和密码 self.username = 'your username' self.passwd = 'your password' # 对登陆数据进行编码 self.encode_data = urllib.urlencode(&#123; # 从网页中分析得到的表单的属性 yhm 、mm， 具体代码见下 'yhm': self.username, 'mm': self.passwd, &#125;) self.opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(self.cj))# 模拟登录def login(self): # 构造请求， 在登录时不检查请求头 request = urllib2.Request(self.login_url, self.encode_data) # 得到反馈结果 response = self.opener.open(request) # 一系列后续设置 self.res_url = response.geturl() self.cookie = self.res_url[46:89].upper() self.referer = self.res_url.replace(';' + self.cookie, '') 由于需要对表单中的用户名和密码框进行分析，故贴上分析代码，也就是获取input框 12345678910# 获取界面中的表单提交def parse_form(html): # 使用 BeautifulSoup进行页面分析，BeautifulSoup的用法见 # https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html soup = BeautifulSoup(html, 'lxml') data = &#123;&#125; for i in soup.find_all('input'): if i.get('name'): data[i.get('name')] = i.get('value') return data 如是需要获取整个页面的代码，使用 download 函数， 下面是download函数的代码 12345678910111213# 第一个参数是需要获得代码的url，第二个是对服务器请求的请求次数，def download(url, num_retries=2): print('Downloading:', url) try: html = urllib2.urlopen(url).read() except urllib2.URLError as e: print('Download error: ', e.reason) html = None if num_retries &gt; 0: if hasattr(e, 'code') and 500 &lt;= e.code &lt; 600: # recursively retry Sxx HTTP errors return download(url, num_retries - 1) return html 最后各种参数配置好之后就直接进行登陆操作就可以了，获取到登录之后的url打印出来就好了,因为两个函数都写在类HBUE中，先创建HBUE类，再进行登录就好。 1234hbue = HBUE()hbue.login()# 打印登陆后的界面download(hbue.res_url) 于是便成功登录到系统，然后接着进行各种操作 三、获得个人信息新版方正管理系统个人信息不能通过界面直接获取，会抓到空值，通过抓包分析之后，系统通过GET请求获得了首页的个人数据然后显示在主页上，也只有姓名和总学分两项。 个人数据GET请求数据包分析 重要内容 解释 Cookie JSESSIONID=9DF449637264440BE0110** Referer http://218.197.80.13/xtgl/index_initMenu.html?jsdm=xs&amp;_t=******* User-Agent Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0 其中通过刚开始登录取得的cookie值来填充进headers中，里面的Referer中，后面的_t参数是系统对时间的一个加密参数，但是通过登录成功后的url中可以分析出来 代码: 1234567891011header = &#123; 'Referer':hbue.res_url, 'User-Agent':'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0', 'Cookie':cur_cookie&#125;new_url = 'http://218.197.80.13/xtgl/index_cxYhxxIndex.html?xt=jw&amp;_='+time+'&amp;gnmkdmKey=index&amp;sessionUserKey='+hbue.usernamerequest = urllib2.Request(url=new_url, headers=header)print 'request : ', requestresponse = urllib2.urlopen(request)print response.read() 通过上面这段代码可以获取首页中的个人信息，包括姓名和总学分等。但是更加重要的班级、学院等信息没有获取到，需要进入到个人信息界面进行获取。于是通过Firebug抓包分析，打开个人信息新界面是通过POST请求来获得界面，通过查看数据包中的POST请求，来构造data字典。 12345678910111213141516171819202122232425262728293031headers = &#123; 'Referer': hbue.referer, 'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0', 'Cookie': hbue.cookie,&#125;data = &#123; 'dyym': '/xsxxxggl/xsgrxxwh_cxXsgrxx.html', 'gnmkdm': 'N100801', 'gnmkdmKey': 'index', 'gnmkmc': '%E6%9F%A5%E8%AF%A2%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF', 'layout': 'func-layout', 'sessionUserKey': hbue.username,&#125;# 对post的数据进行编码encoded_data = urllib.urlencode(data)url = 'http://218.197.80.13/xsxxxggl/xsgrxxwh_cxXsgrxx.html'req = urllib2.Request(url=url, data=encoded_data, headers=headers)response = urllib2.urlopen(req)res = response.read()soup = BeautifulSoup(res, 'lxml')inf_id = &#123; '学号': 'col_xh', '姓名': 'col_xm', '性别': 'col_xbm', '证件': 'col_zjhm', '专业': 'col_jg_id', '学院': 'col_zyh_id', '班级': 'col_bh_id',&#125;for key, value in inf_id.items(): print key, ' : ', soup.find(id=value).get_text().strip() 通过以上代码构造了POST请求，来访问一个新的界面，并且通过Beautiful来获得需要的各种数据 获得所有成绩同样是在个人信息界面，有一个选项板中是成绩信息。若直接进行获取，则跟在首页上获取个人数据一样是空值，这涉及到对动态网页的访问，想要抓取该数据，需要了解网页是如何加载该数据的。该过程被成为逆向工程。打开该选项卡，在Firebug中查看新的请求，会发现网页通过POST提交来获得了成绩信息。查看返回结果，会发现返回的数据是json格式的，便使用Python的json模块把它解析为一个字典，具体代码如下 12345678910111213141516171819202122232425262728# 抓包分析urlurl = 'http://218.197.80.13/cjcx/cjcx_cxDgXscj.html?doType=query&amp;gnmkdmKey=N100801&amp;sessionUserKey=' + hbue.username# 构造请求头headers = &#123; 'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:53.0) Gecko/20100101 Firefox/53.0', 'Cookie': hbue.cookie, 'HOST': '218.197.80.13', 'Referer': 'http://218.197.80.13/xsxxxggl/xsgrxxwh_cxXsgrxx.html',&#125;# 通过数据包分析data，其中showCount表示一页显示多少数据# time为1是因为刚进选项卡时提交过一次数据，代号为0，由于初始设置只会显示10条信息，于是再次进行提交，该一个页面显示90条数据，获取全部成绩data = &#123; '_search': False, 'queryModel.currentPage': '1', 'queryModel.showCount': '90', 'queryModel.sortOrder': 'asc', 'time': '1', 'xh_id': hbue.username,&#125;# 对POST提交数据进行编码encoded_data = urllib.urlencode(data)request = urllib2.Request(url=url, data=encoded_daheaders=headers)response = urllib2.urlopen(request)res = response.read()# 通过json解析来得到字典，然后访问全部的课程名称、教师姓名、课程成绩print '\n所有课程：'for i in json.loads(res)['items']: print i['kcmc'], i['jsxm'], i['cj'] 获取到了所有的课程和结果，其他信息如计算绩点之类的就很简单了 同时课程表、选课信息之类的信息获取也与之类似，通过构造请求来访问就可以了]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
